<!DOCTYPE html>

















































<html class="hasSidebar hasPageActions hasBreadcrumb conceptual has-default-focus theme-light" lang="ko-kr" dir="ltr"
    data-css-variable-support="true" data-authenticated="false" data-auth-status-determined="false" data-target="docs"
    x-ms-format-detection="none">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta property="og:title" content="API 디자인 지침 - Best practices for cloud applications" />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://docs.microsoft.com/ko-kr/azure/architecture/best-practices/api-design" />
    <meta property="og:description" content="잘 디자인된 Web API를 만드는 방법에 관한 지침입니다." />
    <meta property="og:image" content="https://docs.microsoft.com/en-us/media/logos/logo-ms-social.png" />
    <meta property="og:image:alt" content="Microsoft Logo" />

    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@docsmsft" />


    <meta name="author" content="dragon119" />
    <meta name="bilingual_type" content="hover over" />
    <meta name="breadcrumb_path" content="/azure/architecture/bread/toc.json" />
    <meta name="depot_name" content="MSDN.azure-architecture-center-pr2" />
    <meta name="description" content="잘 디자인된 Web API를 만드는 방법에 관한 지침입니다." />
    <meta name="document_id" content="ad651d6a-f8d8-2050-e7a7-adbae7326112" />
    <meta name="document_version_independent_id" content="4fddd724-cabd-8623-7692-857088c1dccb" />
    <meta name="enable_loc_sxs" content="true" />
    <meta name="gitcommit"
        content="https://github.com/MicrosoftDocs/architecture-center-pr.ko-KR/blob/77f7d84228c676ac76bf7b12d48a332d2b0cea37/docs/best-practices/api-design.md" />
    <meta name="locale" content="ko-kr" />
    <meta name="ms.author" content="pnp" />
    <meta name="ms.contentlocale" content="ko-KR" />
    <meta name="ms.custom" content="seodec18" />
    <meta name="ms.date" content="01/12/2018" />
    <meta name="ms.lasthandoff" content="04/13/2020" />
    <meta name="ms.locfileid" content="80532573" />
    <meta name="ms.openlocfilehash" content="4392fb726755be68a91dd288d440c21c25852cb7" />
    <meta name="ms.service" content="architecture-center" />
    <meta name="ms.sourcegitcommit" content="873d29923adb7efb7e4f932de1ae289a431391c0" />
    <meta name="ms.subservice" content="cloud-fundamentals" />
    <meta name="ms.topic" content="best-practice" />
    <meta name="ms.translationtype" content="MT" />
    <meta name="original_content_git_url"
        content="https://github.com/MicrosoftDocs/architecture-center-pr.ko-KR/blob/live-sxs/docs/best-practices/api-design.md" />
    <meta name="search.ms_docsetname" content="azure-architecture-center-pr2" />
    <meta name="search.ms_product" content="MSDN" />
    <meta name="search.ms_sitename" content="Docs" />
    <meta name="site_name" content="Docs" />
    <meta name="uhfHeaderId" content="azure" />
    <meta name="updated_at" content="2020-04-14 05:10 PM" />
    <meta name="page_type" content="conceptual" />
    <meta name="toc_rel" content="../toc.json" />
    <meta name="word_count" content="17441" />


    <meta name="scope" content="Azure, Azure Architecture Center, Application Architecture Guide" />
    <link href="https://docs.microsoft.com/ko-kr/azure/architecture/best-practices/api-design" rel="canonical">
    <title>API 디자인 지침 - Best practices for cloud applications | Microsoft Docs</title>

    <link rel="stylesheet" href="/_themes/docs.theme/master/ko-kr/_themes/styles/4b6bc452.site-ltr.css ">

    <link rel="stylesheet" href="/_themes/docs.theme/master/ko-kr/_themes/styles/5a8a71c1.conceptual.css ">


    <script>
        var msDocs = {
            data: {
                timeOrigin: Date.now(),
                contentLocale: 'ko-kr',
                contentDir: 'ltr',
                userLocale: 'ko-kr',
                userDir: 'ltr',
                pageTemplate: 'Conceptual',
                brand: 'azure',
                context: {

                },
                hasBinaryRating: true,
                hasGithubIssues: true,
                showFeedbackReport: false,
                enableTutorialFeedback: false,
                feedbackSystem: 'GitHub',
                feedbackGitHubRepo: 'MicrosoftDocs/architecture-center.ko-kr',
                feedbackProductUrl: '',
                contentGitUrl: 'https://github.com/microsoftdocs/architecture-center.ko-kr/blob/live/docs/best-practices/api-design.md',
                extendBreadcrumb: false,
                isEditDisplayable: false,
                hideViewSource: false,
                hasPageActions: true,
                hasBookmark: true,
                hasShare: true
            },
            functions: {}
        };
    </script>
    <script nomodule src="/static/third-party/bluebird/3.5.0/bluebird.min.js"
        integrity="sha384-aD4BDeDGeLXLpPK4yKeqtZQa9dv4a/7mQ+4L5vwshIYH1Mc2BrXvHd32iHzYCQy5"
        crossorigin="anonymous"></script>
    <script nomodule src="/static/third-party/fetch/3.0.0/fetch.umd.min.js"
        integrity="sha384-EQIXrC5K2+7X8nGgLkB995I0/6jfAvvyG1ieZ+WYGxgJHFMD/alsG9fSDWvzb5Y1"
        crossorigin="anonymous"></script>
    <script nomodule src="/static/third-party/template/1.4.0/template.min.js"
        integrity="sha384-1zKzI6ldTVHMU7n0W2HpE/lhHI+UG4D9IIaxbj3kT2UhCWicdTuJkTtnKuu0CQzN"
        crossorigin="anonymous"></script>
    <script nomodule src="/static/third-party/url/0.5.7/url.min.js"
        integrity="sha384-vn7xBMtpSTfzaTRWxj0kVq0UcsbBrTOgZ/M1ISHqe1V358elYva+lfiEC+T8jLPc"
        crossorigin="anonymous"></script>
    <script nomodule src="/_themes/docs.theme/master/ko-kr/_themes/scripts/7501e2bd.index-polyfills.js"></script>
    <script src="/_themes/docs.theme/master/ko-kr/_themes/scripts/8de3ca08.index-docs.js"></script>
</head>

<body lang="ko-kr" dir="ltr">
    <a href="#abcdefghijklmn">앵커 테스트!</a>
    <div class="header-holder has-default-focus">
        <a href="#main"
            class="skip-to-main-link has-outline-color-text visually-hidden-until-focused is-fixed has-inner-focus focus-visible has-top-zero has-left-zero has-right-zero has-padding-medium has-text-centered has-body-background-medium"
            tabindex="1">주요 콘텐츠로 건너뛰기</a>
        <div id="headerAreaHolder" data-bi-name="header">
            <header role="banner" itemscope="itemscope" itemtype="http://schema.org/Organization">
                <div class="nav-bar">
                    <div class="nav-bar-brand">
                        <a itemprop="url" href="https://www.microsoft.com" aria-label="Microsoft"
                            class="nav-bar-button">
                            <div class="nav-bar-logo has-background-image theme-display is-light" role="presentation"
                                aria-hidden="true" itemprop="logo" itemscope="itemscope"></div>
                            <div class="nav-bar-logo has-background-image theme-display is-dark is-high-contrast"
                                role="presentation" aria-hidden="true" itemprop="logo" itemscope="itemscope"></div>
                        </a>
                    </div>
                    <div class="nav-bar-item is-hidden-tablet">
                        <button class="nav-bar-button nav-bar-menu" title="전역 탐색">
                            <span class="nav-bar-menu-title"></span>
                            <div class="nav-bar-burger">
                                <span></span>
                                <span></span>
                                <span></span>
                                <span class="nav-bar-burger-label">전역 탐색</span>
                            </div>
                        </button>
                    </div>
                    <nav class="nav-bar-nav" role="navigation" aria-label="전역">
                        <ul class="nav-bar-nav-list">
                            <li class="nav-bar-item is-category">
                                <a class="nav-bar-button is-title has-hover-underline" itemprop="url" href="/en-us/">
                                    <span>Docs</span>
                                </a>
                            </li>
                            <li class="nav-bar-item">
                                <a class="nav-bar-button has-hover-underline" href="/en-us/">
                                    <span>설명서</span>
                                </a>
                            </li>
                            <li class="nav-bar-item">
                                <a class="nav-bar-button has-hover-underline" href="/en-us/learn/">
                                    <span>Learn</span>
                                </a>
                            </li>
                            <li class="nav-bar-item">
                                <a class="nav-bar-button has-hover-underline" href="/en-us/samples/browse/">
                                    <span>코드 샘플</span>
                                </a>
                            </li>
                            <li class="dropdown nav-bar-item" hidden="">
                                <button aria-expanded="false"
                                    class="dropdown-trigger nav-bar-button has-hover-underline" aria-controls="ax-53">
                                    <span>자세히</span>
                                    <span class="nav-bar-button-chevron" aria-hidden="true">
                                        <span class="docon docon-chevron-down-light expanded-indicator"></span>
                                    </span>
                                </button>
                                <ul class="dropdown-menu" id="ax-53" aria-label="자세히">
                                    <li class="nav-bar-item" hidden="">
                                        <a class="nav-bar-button" href="/en-us/">설명서</a>
                                    </li>
                                    <li class="nav-bar-item" hidden="">
                                        <a class="nav-bar-button" href="/en-us/learn/">Learn</a>
                                    </li>
                                    <li class="nav-bar-item" hidden="">
                                        <a class="nav-bar-button" href="/en-us/samples/browse/">코드 샘플</a>
                                    </li>
                                </ul>
                            </li>
                        </ul>
                    </nav>
                    <span class="nav-bar-spacer"></span>
                    <div class="nav-bar-item">
                    </div>
                    <div class="nav-bar-item is-size-7 is-hidden-mobile">
                    </div>
                </div>
                <div class="nav-bar is-content">
                </div>
            </header>
        </div>
        <div class="content-header uhf-container has-padding has-default-focus has-border-bottom-none"
            data-bi-name="content-header">
            <nav class="has-padding-none has-padding-left-medium-tablet has-padding-right-medium-tablet has-padding-left-none-uhf-tablet has-padding-left-none-uhf-tablet has-padding-none-desktop has-flex-grow"
                data-bi-name="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList" role="navigation"
                aria-label="이동 경로">
                <ul id="page-breadcrumbs" class="breadcrumbs">
                </ul>
            </nav>
            <div class="content-header-controls">
                <button type="button" class="contents-button button" data-bi-name="contents-expand"
                    aria-haspopup="true">
                    <span class="icon"><span class="docon docon-menu" aria-hidden="true"></span></span>
                    <span class="contents-expand-title">콘텐츠</span>
                </button>
            </div>
            <div class="content-header-controls exit-focus">
                <button type="button" class="ap-collapse-behavior ap-expanded button" data-bi-name="ap-collapse"
                    aria-controls="action-panel">
                    <span class="icon"><span class="docon docon-exit-mode" aria-hidden="true"></span></span>
                    <span>포커스 모드 종료</span>
                </button>
            </div>
            <div
                class="has-padding-none-tablet has-padding-medium is-size-7 is-flex-touch has-flex-justify-content-space-between-touch has-flex-grow">
                <ul
                    class="is-hidden-mobile action-list has-flex-justify-content-start has-flex-justify-content-end-tablet is-flex is-flex-row has-flex-wrap has-flex-grow is-unstyled">
                    <li>
                        <button type="button"
                            class="bookmark button is-text has-inner-focus is-small is-icon-only-touch"
                            data-list-type="bookmarks" data-bi-name="bookmark" title="이 페이지에 책갈피 지정">
                            <span class="icon" aria-hidden="true">
                                <span class="docon docon-single-bookmark"></span>
                            </span>
                            <span class="bookmark-status is-visually-hidden-touch is-hidden-portrait">책갈피</span>
                        </button>
                    </li>
                    <li id="feedback-section-link">
                        <a href="#feedback" class="button is-text has-inner-focus is-small is-icon-only-touch"
                            data-bi-name="comments" title="이 페이지에 대한 피드백 보내기">
                            <span class="icon">
                                <span class="docon docon-comment-lines" aria-hidden="true"></span>
                            </span>
                            <span class="is-visually-hidden-touch is-hidden-portrait">피드백</span>
                        </a>
                    </li>
                    <li id="contenteditbtn" hidden>
                        <a href="https://github.com/microsoftdocs/architecture-center.ko-kr/blob/live/docs/best-practices/api-design.md"
                            class="button is-text has-inner-focus is-icon-only-touch is-small" title="이 문서 편집"
                            data-bi-name="edit"
                            data-original_content_git_url="https://github.com/MicrosoftDocs/architecture-center-pr.ko-KR/blob/live-sxs/docs/best-practices/api-design.md"
                            data-original_content_git_url_template="{repo}/blob/{branch}/docs/best-practices/api-design.md"
                            data-pr_repo="" data-pr_branch="">
                            <span class="icon">
                                <span class="docon docon-edit-outline" aria-hidden="true"></span>
                            </span>
                            <span class="is-visually-hidden-touch is-hidden-portrait">편집</span>
                        </a>
                    </li>
                    <li>
                        <div class="sharing dropdown has-caret">
                            <button
                                class="dropdown-trigger button is-text is-fullwidth has-flex-justify-content-start has-inner-focus is-small is-icon-only-touch"
                                aria-controls="sharing-menu" aria-expanded="false" title="이 문서 공유" data-bi-name="share">
                                <span class="icon" aria-hidden="true">
                                    <span class="docon docon-sharing"></span>
                                </span>
                                <span class="is-visually-hidden-touch is-hidden-portrait">공유</span>
                            </button>
                            <div class="dropdown-menu has-padding-small" id="sharing-menu">
                                <ul data-bi-name="share-links">
                                    <li>
                                        <a class="button is-text is-fullwidth has-flex-justify-content-start has-inner-focus is-small share-twitter"
                                            data-bi-name="twitter">
                                            <span class="icon">
                                                <span class="docon docon-brand-twitter has-text-primary"
                                                    aria-hidden="true"></span>
                                            </span>
                                            <span>Twitter</span>
                                        </a>
                                    </li>
                                    <li>
                                        <a class="button is-text is-fullwidth has-flex-justify-content-start has-inner-focus is-small share-linkedin"
                                            data-bi-name="linkedin">
                                            <span class="icon">
                                                <span class="docon docon-brand-linkedin has-text-primary"
                                                    aria-hidden="true"></span>
                                            </span>
                                            <span>LinkedIn</span>
                                        </a>
                                    </li>
                                    <li>
                                        <a class="button is-text is-fullwidth has-flex-justify-content-start has-inner-focus is-small share-facebook"
                                            data-bi-name="facebook">
                                            <span class="icon">
                                                <span class="docon docon-brand-facebook has-text-primary"
                                                    aria-hidden="true"></span>
                                            </span>
                                            <span>Facebook</span>
                                        </a>
                                    </li>
                                    <li>
                                        <a class="button is-text is-fullwidth has-flex-justify-content-start has-inner-focus is-small share-email"
                                            data-bi-name="email">
                                            <span class="icon">
                                                <span class="docon docon-mail-message-fill has-text-primary"
                                                    aria-hidden="true"></span>
                                            </span>
                                            <span>메일</span>
                                        </a>
                                    </li>
                                </ul>
                            </div>
                        </div>
                    </li>
                    <li>

                        <div class="lang-toggle-container">
                            <label for="language-toggle" aria-hidden="true" tabindex="-1">영어로 읽기</label>
                            <div class="checkbox-toggle-wrapper">
                                <input type="checkbox" id="language-toggle" aria-label="영어로 읽기">
                                <label for="language-toggle" class="switch"></label>
                            </div>
                        </div>
                    </li>
                </ul>
                <button type="button"
                    class="has-border contents-button button is-small is-text is-hidden-tablet has-inner-focus"
                    aria-label="콘텐츠" data-bi-name="contents-expand">
                    <span class="icon">
                        <span class="docon docon-editor-list-bullet" aria-hidden="true"></span>
                    </span>
                    <span class="contents-expand-title">목차</span>
                </button>
                <div class="is-invisible"></div>
                <div class="is-hidden-tablet level-item is-flexible level-right">
                    <button type="button"
                        class="page-actions-button button is-small is-text is-hidden-tablet has-inner-focus has-border is-full-height  has-margin-left-small"
                        aria-label="페이지 작업" data-bi-name="pageactions">
                        <span class="icon">
                            <span class="docon docon-more-vertical" aria-hidden="true"></span>
                        </span>
                    </button>
                </div>
            </div>
        </div>

        <div id="disclaimer-holder" class="has-overflow-hidden has-default-focus"></div>
    </div>

    <div class="mainContainer  uhf-container has-top-padding  has-default-focus" data-bi-name="body">

        <div class="columns has-large-gaps is-gapless-mobile ">

            <div id="left-container"
                class="left-container is-hidden-mobile column is-one-third-tablet is-one-quarter-desktop">
                <nav id="affixed-left-container" class="is-fixed is-flex is-flex-column" role="navigation"
                    aria-label="기본"></nav>
            </div>

            <section class="primary-holder column is-two-thirds-tablet is-three-quarters-desktop">
                <div class="columns is-gapless-mobile has-large-gaps ">


                    <div id="main-column" class="column  is-full is-four-fifths-desktop ">

                        <main id="main" role="main" class="content " data-bi-name="content" lang="ko-kr" dir="ltr">



                            <h1 id="web-api-design"><span data-ttu-id="1422d-103">웹 API 디자인</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-103">Web API design</span></span></h1>

                            <ul class="metadata page-metadata" data-bi-name="page info" lang="ko-kr" dir="ltr">
                                <li>
                                    <time class="is-invisible" data-article-date aria-label="문서 검토 날짜"
                                        datetime="2018-01-12T00:00:00.000Z"
                                        data-article-date-source="ms.date">01/12/2018</time>
                                </li>
                                <li class="readingTime">읽는 데 43분 걸림</li>
                                <li class="contributors-holder">
                                    <a href="https://github.com/microsoftdocs/architecture-center.ko-kr/blob/live/docs/best-practices/api-design.md"
                                        title="1 참가자" aria-label="1 참가자">
                                        <ul class="contributors" data-bi-name="contributors" aria-hidden="true">
                                            <li><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNMsAcAAQUAoVnxsV8AAAAASUVORK5CYII="
                                                    data-src="https://github.com/dragon119.png?size=32"
                                                    role="presentation" /></li>
                                        </ul>
                                    </a>
                                </li>
                            </ul>

                            <nav id="center-doc-outline" class="doc-outline is-hidden-desktop"
                                data-bi-name="intopic toc" role="navigation" aria-label="문서 개요">
                                <h3>이 문서의 내용</h3>
                            </nav>

                            <!-- <content> -->
                            <!-- cSpell:ignore HATEOAS -->
                            <p><span data-ttu-id="1422d-104">대부분의 최신 웹 애플리케이션은 클라이언트가 애플리케이션과 상호 작용하는 데 사용할 수 있는 API를
                                    표시합니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-104">Most modern web
                                        applications expose APIs that clients can use to interact with the
                                        application.</span></span> <span data-ttu-id="1422d-105">잘 디자인된 웹 API는 아래와 같은
                                    특성을 지원해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-105">A
                                        well-designed web API should aim to support:</span></span></p>
                            <ul>
                                <li>
                                    <p><span data-ttu-id="1422d-106"><strong>플랫폼 독립성</strong>.</span><span
                                            class="sxs-lookup"><span data-stu-id="1422d-106"><strong>Platform
                                                    independence</strong>.</span></span> <span
                                            data-ttu-id="1422d-107">모든 클라이언트는 내부에서 API가 구현되는 방법에 관계없이 API를 호출할 수 있어야
                                            합니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-107">Any client
                                                should be able to call the API, regardless of how the API is implemented
                                                internally.</span></span> <span data-ttu-id="1422d-108">그러려면 표준 프로토콜을
                                            사용해야 하고, 클라이언트 및 웹 서비스가 교환할 데이터 형식에 동의할 수 있는 메커니즘이 있어야 합니다.</span><span
                                            class="sxs-lookup"><span data-stu-id="1422d-108">This requires using
                                                standard protocols, and having a mechanism whereby the client and the
                                                web service can agree on the format of the data to
                                                exchange.</span></span></p>
                                </li>
                                <li>
                                    <p><span data-ttu-id="1422d-109"><strong>서비스 진화</strong>.</span><span
                                            class="sxs-lookup"><span data-stu-id="1422d-109"><strong>Service
                                                    evolution</strong>.</span></span> <span data-ttu-id="1422d-110">Web
                                            API는 클라이언트 애플리케이션과 독립적으로 기능을 진화시키고 추가할 수 있어야 합니다.</span><span
                                            class="sxs-lookup"><span data-stu-id="1422d-110">The web API should be able
                                                to evolve and add functionality independently from client
                                                applications.</span></span> <span data-ttu-id="1422d-111">API가 진화해도 기존
                                            클라이언트 애플리케이션은 수정 없이 계속 작동할 수 있어야 합니다.</span><span class="sxs-lookup"><span
                                                data-stu-id="1422d-111">As the API evolves, existing client applications
                                                should continue to function without modification.</span></span> <span
                                            data-ttu-id="1422d-112">모든 기능은 클라이언트 애플리케이션이 해당 기능을 완전히 이용할 수 있도록 검색이 가능해야
                                            합니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-112">All
                                                functionality should be discoverable so that client applications can
                                                fully use it.</span></span></p>
                                </li>
                            </ul>
                            <p><span data-ttu-id="1422d-113">이 지침에서는 Web API를 디자인할 때 고려해야 하는 사항을 설명합니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-113">This guidance describes issues that
                                        you should consider when designing a web API.</span></span></p>
                            <h2 id="introduction-to-rest"><span data-ttu-id="1422d-114">REST 소개</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-114">Introduction to REST</span></span>
                            </h2>
                            <p><span data-ttu-id="1422d-115">2000년에 Roy Fielding은 웹 서비스를 디자인하는 아키텍처 접근 방식으로
                                    REST(Representational State Transfer)를 제안했습니다.</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-115">In 2000, Roy Fielding proposed Representational State
                                        Transfer (REST) as an architectural approach to designing web
                                        services.</span></span> <span data-ttu-id="1422d-116">REST는 하이퍼미디어 기반 분산 시스템을
                                    구축하기 위한 아키텍처 스타일입니다.</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-116">REST is an architectural style for building distributed
                                        systems based on hypermedia.</span></span> <span data-ttu-id="1422d-117">REST는
                                    어떤 기본 프로토콜과도 독립적이며 HTTP에 연결될 필요가 없습니다.</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-117">REST is independent of any underlying protocol and is
                                        not necessarily tied to HTTP.</span></span> <span data-ttu-id="1422d-118">그러나
                                    대부분의 일반적인 REST 구현에서 애플리케이션 프로토콜로 HTTP를 사용하고, 이 지침에서는 HTTP를 위한 REST API 디자인에 중점을
                                    둡니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-118">However, most
                                        common REST implementations use HTTP as the application protocol, and this guide
                                        focuses on designing REST APIs for HTTP.</span></span></p>
                            <p><span data-ttu-id="1422d-119">REST가 HTTP보다 우수한 주요 장점은 개방형 표준을 사용하므로 API 또는 클라이언트 애플리케이션의
                                    구현이 특정 구현에 바인딩되지 않는다는 것입니다.</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-119">A primary advantage of REST over HTTP is that it uses
                                        open standards, and does not bind the implementation of the API or the client
                                        applications to any specific implementation.</span></span> <span
                                    data-ttu-id="1422d-120">예를 들어 REST 웹 서비스는 ASP.NET으로 작성할 수 있으며, 클라이언트 애플리케이션은 HTTP
                                    요청을 생성하고 HTTP 응답을 구문 분석할 수 있는 모든 언어 또는 도구 집합을 사용할 수 있습니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-120">For example, a REST web service
                                        could be written in ASP.NET, and client applications can use any language or
                                        toolset that can generate HTTP requests and parse HTTP responses.</span></span>
                            </p>
                            <p><span data-ttu-id="1422d-121">다음은 HTTP를 사용하는 RESTful API의 몇 가지 기본 디자인 원칙입니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-121">Here are some of the main design
                                        principles of RESTful APIs using HTTP:</span></span></p>
                            <ul>
                                <li>
                                    <p><span data-ttu-id="1422d-122">REST API는 <em>리소스</em>를 중심으로 디자인되며, 클라이언트에서 액세스할 수
                                            있는 모든 종류의 개체, 데이터 또는 서비스가 리소스에 포함됩니다.</span><span class="sxs-lookup"><span
                                                data-stu-id="1422d-122">REST APIs are designed around
                                                <em>resources</em>, which are any kind of object, data, or service that
                                                can be accessed by the client.</span></span></p>
                                </li>
                                <li>
                                    <p><span data-ttu-id="1422d-123">리소스마다 해당 리소스를 고유하게 식별하는 URI인 <em>식별자</em>가
                                            있습니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-123">A
                                                resource has an <em>identifier</em>, which is a URI that uniquely
                                                identifies that resource.</span></span> <span data-ttu-id="1422d-124">예를
                                            들어 특정 고객 주문의 URI는 다음과 같습니다.</span><span class="sxs-lookup"><span
                                                data-stu-id="1422d-124">For example, the URI for a particular customer
                                                order might be:</span></span></p>
                                    <pre><code class="lang-http">https://adventure-works.com/orders/1
</code></pre>
                                </li>
                                <li>
                                    <p><span data-ttu-id="1422d-125">클라이언트가 리소스의 <em>표현</em>을 교환하여 서비스와 상호
                                            작용합니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-125">Clients
                                                interact with a service by exchanging <em>representations</em> of
                                                resources.</span></span> <span data-ttu-id="1422d-126">많은 Web API가 교환
                                            형식으로 JSON을 사용합니다.</span><span class="sxs-lookup"><span
                                                data-stu-id="1422d-126">Many web APIs use JSON as the exchange
                                                format.</span></span> <span data-ttu-id="1422d-127">예를 들어 위에 나열된 URI에 대한
                                            GET 요청은 이 응답 본문을 반환할 수 있습니다.</span><span class="sxs-lookup"><span
                                                data-stu-id="1422d-127">For example, a GET request to the URI listed
                                                above might return this response body:</span></span></p>
                                    <pre><code class="lang-json">{&quot;orderId&quot;:1,&quot;orderValue&quot;:99.90,&quot;productId&quot;:1,&quot;quantity&quot;:1}
</code></pre>
                                </li>
                                <li>
                                    <p><span data-ttu-id="1422d-128">REST API는 균일한 인터페이스를 사용하므로 클라이언트와 서비스 구현을 분리하는 데
                                            도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-128">REST
                                                APIs use a uniform interface, which helps to decouple the client and
                                                service implementations.</span></span> <span
                                            data-ttu-id="1422d-129">HTTP를 기반으로 하는 REST API의 경우 리소스에 표준 HTTP 동사 수행 작업을
                                            사용하는 것이 균일한 인터페이스에 포함됩니다.</span><span class="sxs-lookup"><span
                                                data-stu-id="1422d-129">For REST APIs built on HTTP, the uniform
                                                interface includes using standard HTTP verbs to perform operations on
                                                resources.</span></span> <span data-ttu-id="1422d-130">가장 일반적인 작업은 GET,
                                            POST, PUT, PATCH 및 DELETE입니다.</span><span class="sxs-lookup"><span
                                                data-stu-id="1422d-130">The most common operations are GET, POST, PUT,
                                                PATCH, and DELETE.</span></span></p>
                                </li>
                                <li>
                                    <p><span data-ttu-id="1422d-131">REST API는 상태 비저장 요청 모델을 사용합니다.</span><span
                                            class="sxs-lookup"><span data-stu-id="1422d-131">REST APIs use a stateless
                                                request model.</span></span> <span data-ttu-id="1422d-132">HTTP 요청은
                                            독립적이어야 하고 임의 순서로 발생할 수 있으므로, 요청 사이에 일시적인 상태 정보를 유지할 수 없습니다.</span><span
                                            class="sxs-lookup"><span data-stu-id="1422d-132">HTTP requests should be
                                                independent and may occur in any order, so keeping transient state
                                                information between requests is not feasible.</span></span> <span
                                            data-ttu-id="1422d-133">정보는 리소스 자체에만 저장되며 각 요청은 자동 작업이어야 합니다.</span><span
                                            class="sxs-lookup"><span data-stu-id="1422d-133">The only place where
                                                information is stored is in the resources themselves, and each request
                                                should be an atomic operation.</span></span> <span
                                            data-ttu-id="1422d-134">이러한 제약 조건이 있기 때문에 웹 서비스의 확장성이 우수합니다. 클라이언트와 특정 서버
                                            사이에 선호도를 유지할 필요가 없기 때문입니다.</span><span class="sxs-lookup"><span
                                                data-stu-id="1422d-134">This constraint enables web services to be
                                                highly scalable, because there is no need to retain any affinity between
                                                clients and specific servers.</span></span> <span
                                            data-ttu-id="1422d-135">모든 서버는 모든 클라이언트의 모든 요청을 처리할 수 있습니다.</span><span
                                            class="sxs-lookup"><span data-stu-id="1422d-135">Any server can handle any
                                                request from any client.</span></span> <span data-ttu-id="1422d-136">그렇긴
                                            하지만, 다른 요소가 확장성을 제한할 수 있습니다.</span><span class="sxs-lookup"><span
                                                data-stu-id="1422d-136">That said, other factors can limit
                                                scalability.</span></span> <span data-ttu-id="1422d-137">예를 들어 많은 웹 서비스가
                                            백 엔드 데이터 저장소에 쓰기하므로 확장하기 어려울 수 있습니다. 데이터 저장소를 확장하는 전략에 대한 자세한 내용은 <a
                                                href="data-partitioning" data-linktype="relative-path">가로, 세로 및 기능 데이터
                                                분할을</a>참조하십시오.</span><span class="sxs-lookup"><span
                                                data-stu-id="1422d-137">For example, many web services write to a
                                                backend data store, which may be hard to scale out. For more information
                                                about strategies to scale out a data store, see <a
                                                    href="data-partitioning" data-linktype="relative-path">Horizontal,
                                                    vertical, and functional data partitioning</a>.</span></span></p>
                                </li>
                                <li>
                                    <p><span data-ttu-id="1422d-138">REST API는 표현에 포함된 하이퍼미디어 링크에 따라 구동됩니다.</span><span
                                            class="sxs-lookup"><span data-stu-id="1422d-138">REST APIs are driven by
                                                hypermedia links that are contained in the representation.</span></span>
                                        <span data-ttu-id="1422d-139">예를 들어 다음은 주문의 JSON 표현을 보여줍니다.</span><span
                                            class="sxs-lookup"><span data-stu-id="1422d-139">For example, the following
                                                shows a JSON representation of an order.</span></span> <span
                                            data-ttu-id="1422d-140">주문과 관련된 고객을 가져오거나 업데이트하는 링크를 포함하고 있습니다.</span><span
                                            class="sxs-lookup"><span data-stu-id="1422d-140">It contains links to get or
                                                update the customer associated with the order.</span></span></p>
                                    <pre><code class="lang-json">{
    &quot;orderID&quot;:3,
    &quot;productID&quot;:2,
    &quot;quantity&quot;:4,
    &quot;orderValue&quot;:16.60,
    &quot;links&quot;: [
        {&quot;rel&quot;:&quot;product&quot;,&quot;href&quot;:&quot;https://adventure-works.com/customers/3&quot;, &quot;action&quot;:&quot;GET&quot; },
        {&quot;rel&quot;:&quot;product&quot;,&quot;href&quot;:&quot;https://adventure-works.com/customers/3&quot;, &quot;action&quot;:&quot;PUT&quot; }
    ]
}
</code></pre>
                                </li>
                            </ul>
                            <p><span data-ttu-id="1422d-141">2008년에 Leonard Richardson은 Web API에 대한 다음과 같은 <a
                                        href="https://martinfowler.com/articles/richardsonMaturityModel.html"
                                        data-linktype="external">성숙도 모델</a>을 제안했습니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-141">In 2008, Leonard Richardson
                                        proposed the following <a
                                            href="https://martinfowler.com/articles/richardsonMaturityModel.html"
                                            data-linktype="external">maturity model</a> for web APIs:</span></span></p>
                            <ul>
                                <li><span data-ttu-id="1422d-142">수준 0: 한 URI를 정의합니다. 모든 작업은 이 URI에 대한 POST
                                        요청입니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-142">Level 0:
                                            Define one URI, and all operations are POST requests to this
                                            URI.</span></span></li>
                                <li><span data-ttu-id="1422d-143">수준 1: 개별 리소스에 대한 별도의 URI를 만듭니다.</span><span
                                        class="sxs-lookup"><span data-stu-id="1422d-143">Level 1: Create separate URIs
                                            for individual resources.</span></span></li>
                                <li><span data-ttu-id="1422d-144">수준 2: HTTP 메서드를 사용하여 리소스에 대한 작업을 정의합니다.</span><span
                                        class="sxs-lookup"><span data-stu-id="1422d-144">Level 2: Use HTTP methods to
                                            define operations on resources.</span></span></li>
                                <li><span data-ttu-id="1422d-145">수준 3: 하이퍼미디어(HATEOAS, 아래에 설명)를 사용합니다.</span><span
                                        class="sxs-lookup"><span data-stu-id="1422d-145">Level 3: Use hypermedia
                                            (HATEOAS, described below).</span></span></li>
                            </ul>
                            <p><span data-ttu-id="1422d-146">수준 3은 Fielding의 정의에 따르면 진정한 RESTful API에 해당합니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-146">Level 3 corresponds to a truly
                                        RESTful API according to Fielding's definition.</span></span> <span
                                    data-ttu-id="1422d-147">실제로 게시된 여러 Web API가 수준 2의 어딘가에 해당합니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-147">In practice, many published web
                                        APIs fall somewhere around level 2.</span></span></p>
                            <h2 id="organize-the-api-around-resources"><span data-ttu-id="1422d-148">리소스를 중심으로 API
                                    구성</span><span class="sxs-lookup"><span data-stu-id="1422d-148">Organize the API
                                        around resources</span></span></h2>
                            <p><span data-ttu-id="1422d-149">즉, 웹 API가 표시하는 비즈니스 엔터티에 집중해야 합니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-149">Focus on the business entities that
                                        the web API exposes.</span></span> <span data-ttu-id="1422d-150">예를 들어 전자 상거래
                                    시스템에서는 기본 엔터티가 고객과 주문입니다.</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-150">For example, in an e-commerce system, the primary
                                        entities might be customers and orders.</span></span> <span
                                    data-ttu-id="1422d-151">주문 정보가 포함된 HTTP POST 요청을 전송하여 주문 만들기를 구현할 수
                                    있습니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-151">Creating an order
                                        can be achieved by sending an HTTP POST request that contains the order
                                        information.</span></span> <span data-ttu-id="1422d-152">HTTP 응답은 주문이 성공적으로
                                    수행되었는지 여부를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-152">The
                                        HTTP response indicates whether the order was placed successfully or
                                        not.</span></span> <span data-ttu-id="1422d-153">가능하다면 리소스 URI는 동사(리소스에 대한 작업)가
                                    아닌 명사(리소스)를 기반으로 해야 합니다.</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-153">When possible, resource URIs should be based on nouns
                                        (the resource) and not verbs (the operations on the resource).</span></span></p>
                            <pre><code class="lang-http">https://adventure-works.com/orders // Good

https://adventure-works.com/create-order // Avoid
</code></pre>
                            <p><span data-ttu-id="1422d-154">리소스가 단일 물리적 데이터 항목을 기반으로 할 필요는 없습니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-154">A resource doesn't have to be based
                                        on a single physical data item.</span></span> <span data-ttu-id="1422d-155">예를
                                    들어 주문 리소스는 내부적으로 관계형 데이터베이스의 여러 테이블로 구현할 수 있지만 클라이언트에 대해서는 단일 엔터티로
                                    표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-155">For example, an
                                        order resource might be implemented internally as several tables in a relational
                                        database, but presented to the client as a single entity.</span></span> <span
                                    data-ttu-id="1422d-156">단순히 데이터베이스의 내부 구조를 반영하는 API를 만들지 마세요.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-156">Avoid creating APIs that simply
                                        mirror the internal structure of a database.</span></span> <span
                                    data-ttu-id="1422d-157">REST의 목적은 엔터티 및 해당 엔터티에서 애플리케이션이 수행할 수 있는 작업을 모델링하는
                                    것입니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-157">The purpose of
                                        REST is to model entities and the operations that an application can perform on
                                        those entities.</span></span> <span data-ttu-id="1422d-158">클라이언트는 내부 구현에 노출되면 안
                                    됩니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-158">A client should
                                        not be exposed to the internal implementation.</span></span></p>
                            <p><span data-ttu-id="1422d-159">엔터티는 종종 컬렉션(주문, 고객)으로 그룹화됩니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-159">Entities are often grouped together
                                        into collections (orders, customers).</span></span> <span
                                    data-ttu-id="1422d-160">컬렉션은 컬렉션 내 항목과는 별도의 리소스이며 고유한 URI가 있어야 합니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-160">A collection is a separate resource
                                        from the item within the collection, and should have its own URI.</span></span>
                                <span data-ttu-id="1422d-161">예를 들어 다음 URI는 주문 컬렉션을 나타낼 수 있습니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-161">For example, the following URI
                                        might represent the collection of orders:</span></span></p>
                            <pre><code class="lang-http">https://adventure-works.com/orders
</code></pre>
                            <p><span data-ttu-id="1422d-162">컬렉션 URI에 HTTP GET 요청을 보내면 컬렉션에 있는 항목 목록을 검색합니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-162">Sending an HTTP GET request to the
                                        collection URI retrieves a list of items in the collection.</span></span> <span
                                    data-ttu-id="1422d-163">또한 컬렉션의 항목마다 고유의 URI가 있습니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-163">Each item in the collection also
                                        has its own unique URI.</span></span> <span data-ttu-id="1422d-164">항목의 URI에 대한
                                    HTTP GET 요청은 해당 항목의 세부 정보를 반환합니다.</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-164">An HTTP GET request to the item's URI returns the
                                        details of that item.</span></span></p>
                            <p><span data-ttu-id="1422d-165">URI에 일관적인 명명 규칙을 적용합니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-165">Adopt a consistent naming
                                        convention in URIs.</span></span> <span data-ttu-id="1422d-166">일반적으로 이렇게 하면
                                    컬렉션을 참조하는 URI에 대해 복수 명사를 사용할 수 있습니다.</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-166">In general, it helps to use plural nouns for URIs that
                                        reference collections.</span></span> <span data-ttu-id="1422d-167">컬렉션 및 항목에 대한
                                    URI를 계층 구조로 구성하는 것이 좋습니다.</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-167">It's a good practice to organize URIs for collections
                                        and items into a hierarchy.</span></span> <span data-ttu-id="1422d-168">예를 들어
                                    <code>/customers</code>는 고객 컬렉션의 경로이고, <code>/customers/5</code>는 ID가 5인 고객의
                                    경로입니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-168">For example,
                                        <code>/customers</code> is the path to the customers collection, and
                                        <code>/customers/5</code> is the path to the customer with ID equal to
                                        5.</span></span> <span data-ttu-id="1422d-169">이 접근 방식을 사용하면 웹 API를 직관적으로 유지할 수
                                    있습니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-169">This approach
                                        helps to keep the web API intuitive.</span></span> <span
                                    data-ttu-id="1422d-170">또한 많은 Web API 프레임워크는 매개 변수가 있는 URI 경로를 기반으로 요청을 라우팅할 수 있으므로
                                    개발자는 경로 <code>/customers/{id}</code>에 대한 경로를 정의할 수 있습니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-170">Also, many web API frameworks can
                                        route requests based on parameterized URI paths, so you could define a route for
                                        the path <code>/customers/{id}</code>.</span></span></p>
                            <p><span data-ttu-id="1422d-171">서로 다른 리소스 형식과 이러한 연결을 표시하는 방법 사이의 관계도 고려해야 합니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-171">Also consider the relationships
                                        between different types of resources and how you might expose these
                                        associations.</span></span> <span data-ttu-id="1422d-172">예를 들어
                                    <code>/customers/5/orders</code>는 고객 5에 대한 모든 주문을 나타낼 수 있습니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-172">For example, the
                                        <code>/customers/5/orders</code> might represent all of the orders for customer
                                        5.</span></span> <span data-ttu-id="1422d-173">반대 방향으로 이동하여
                                    <code>/orders/99/customer</code> 같은 URI를 사용하여 주문에서 고객으로의 연결을 표시할 수도
                                    있습니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-173">You could also go
                                        in the other direction, and represent the association from an order back to a
                                        customer with a URI such as <code>/orders/99/customer</code>.</span></span>
                                <span data-ttu-id="1422d-174">그러나 이 모델을 너무 많이 확장하면 구현이 어려울 수 있습니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-174">However, extending this model too
                                        far can become cumbersome to implement.</span></span> <span
                                    data-ttu-id="1422d-175">HTTP 응답 메시지의 본문에 연결된 리소스에 대한 탐색 가능한 링크를 제공하는 방법이 더
                                    좋습니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-175">A better solution
                                        is to provide navigable links to associated resources in the body of the HTTP
                                        response message.</span></span> <span data-ttu-id="1422d-176">이 메커니즘은 <a
                                        href="#use-hateoas-to-enable-navigation-to-related-resources"
                                        data-linktype="self-bookmark">관련 리소스에 대한 탐색을 활성화하기 위해 HATEOAS 사용</a>섹션에서 자세히
                                    설명합니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-176">This mechanism
                                        is described in more detail in the section <a
                                            href="#use-hateoas-to-enable-navigation-to-related-resources"
                                            data-linktype="self-bookmark">Use HATEOAS to enable navigation to related
                                            resources</a>.</span></span></p>
                            <p><span data-ttu-id="1422d-177">좀 더 복잡한 시스템에서는
                                    <code>/customers/1/orders/99/products</code>처럼 클라이언트가 여러 관계 수준을 탐색할 수 있는 URI를 제공하고
                                    싶을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-177">In more
                                        complex systems, it can be tempting to provide URIs that enable a client to
                                        navigate through several levels of relationships, such as
                                        <code>/customers/1/orders/99/products</code>.</span></span> <span
                                    data-ttu-id="1422d-178">그러나 이 수준의 복잡성은 유지하기 어려울 수 있으며 나중에 리소스 사이의 관계가 변하면 유연성이
                                    떨어집니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-178">However, this
                                        level of complexity can be difficult to maintain and is inflexible if the
                                        relationships between resources change in the future.</span></span> <span
                                    data-ttu-id="1422d-179">그 대신 URI를 비교적 간단하게 유지해 보세요.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-179">Instead, try to keep URIs
                                        relatively simple.</span></span> <span data-ttu-id="1422d-180">애플리케이션이 리소스 참조를
                                    지정한 후에는 이 참조를 사용하여 해당 리소스와 관련된 항목을 찾을 수 있어야 합니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-180">Once an application has a reference
                                        to a resource, it should be possible to use this reference to find items related
                                        to that resource.</span></span> <span data-ttu-id="1422d-181">이전 쿼리를
                                    <code>/customers/1/orders</code> URI로 바꿔서 고객 1의 모든 주문을 찾은 후
                                    <code>/orders/99/products</code>로 바꿔서 이 주문의 제품을 찾을 수 있습니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-181">The preceding query can be replaced
                                        with the URI <code>/customers/1/orders</code> to find all the orders for
                                        customer 1, and then <code>/orders/99/products</code> to find the products in
                                        this order.</span></span></p>
                            <div class="TIP">
                                <p>팁</p>
                                <p><span data-ttu-id="1422d-182">리소스 URI를 <em>컬렉션/항목/컬렉션</em>보다 더 복잡하게 요구하지 않는 것이
                                        좋습니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-182">Avoid
                                            requiring resource URIs more complex than
                                            <em>collection/item/collection</em>.</span></span></p>
                            </div>
                            <p><span data-ttu-id="1422d-183">또 다른 요소는 모든 웹 요청이 웹 서버의 부하를 높인다는 점입니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-183">Another factor is that all web
                                        requests impose a load on the web server.</span></span> <span
                                    data-ttu-id="1422d-184">요청이 많을수록 부하가 커집니다.</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-184">The more requests, the bigger the load.</span></span>
                                <span data-ttu-id="1422d-185">따라서 다수의 작은 리소스를 표시하는 &quot;번잡한&quot; Web API를 피하도록 노력해야
                                    합니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-185">Therefore, try to
                                        avoid &quot;chatty&quot; web APIs that expose a large number of small
                                        resources.</span></span> <span data-ttu-id="1422d-186">이러한 API를 사용하려면 클라이언트
                                    애플리케이션이 요구하는 모든 데이터를 찾을 수 있도록 여러 요청을 보내야 할 수 있습니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-186">Such an API may require a client
                                        application to send multiple requests to find all of the data that it
                                        requires.</span></span> <span data-ttu-id="1422d-187">그 대신, 데이터를 비정규화하고 단일 요청을
                                    통해 관련 정보를 검색할 수 있는 더 큰 리소스로 결합하는 것이 좋습니다.</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-187">Instead, you might want to denormalize the data and
                                        combine related information into bigger resources that can be retrieved with a
                                        single request.</span></span> <span data-ttu-id="1422d-188">단, 이 접근 방식과 클라이언트에
                                    필요 없는 데이터를 가져오는 오버헤드의 균형을 조정해야 합니다.</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-188">However, you need to balance this approach against the
                                        overhead of fetching data that the client doesn't need.</span></span> <span
                                    data-ttu-id="1422d-189">큰 개체를 검색하면 요청의 대기 시간이 증가하고 추가 대역폭 비용이 발생할 수
                                    있습니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-189">Retrieving large
                                        objects can increase the latency of a request and incur additional bandwidth
                                        costs.</span></span> <span data-ttu-id="1422d-190">이러한 성능 안티패턴에 대한 자세한 내용은 <a
                                        href="../antipatterns/chatty-io/" data-linktype="relative-path">번잡한 I/O</a> 및 <a
                                        href="../antipatterns/extraneous-fetching/" data-linktype="relative-path">불필요한
                                        가져오기</a>를 참조하세요.</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-190">For more information about these performance
                                        antipatterns, see <a href="../antipatterns/chatty-io/"
                                            data-linktype="relative-path">Chatty I/O</a> and <a
                                            href="../antipatterns/extraneous-fetching/"
                                            data-linktype="relative-path">Extraneous Fetching</a>.</span></span></p>
                            <p><span data-ttu-id="1422d-191">Web API와 기본 데이터 원본 사이에 종속성이 발생하지 않도록 해야 합니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-191">Avoid introducing dependencies
                                        between the web API and the underlying data sources.</span></span> <span
                                    data-ttu-id="1422d-192">예를 들어 데이터가 관계형 데이터베이스에 저장되는 경우 Web API는 각 테이블을 리소스 컬렉션으로 표시할
                                    필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-192">For example,
                                        if your data is stored in a relational database, the web API doesn't need to
                                        expose each table as a collection of resources.</span></span> <span
                                    data-ttu-id="1422d-193">사실 이것은 서투른 디자인입니다.</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-193">In fact, that's probably a poor design.</span></span>
                                <span data-ttu-id="1422d-194">그 대신 Web API를 데이터베이스의 추상화라고 생각해 보세요.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-194">Instead, think of the web API as an
                                        abstraction of the database.</span></span> <span data-ttu-id="1422d-195">필요하다면
                                    데이터베이스와 Web API 사이에 매핑 계층을 도입합니다.</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-195">If necessary, introduce a mapping layer between the
                                        database and the web API.</span></span> <span data-ttu-id="1422d-196">이 방법을 사용하면
                                    클라이언트 애플리케이션이 기본 데이터베이스 스키마의 변경 내용으로부터 격리됩니다.</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-196">That way, client applications are isolated from changes
                                        to the underlying database scheme.</span></span></p>
                            <p><span data-ttu-id="1422d-197">마지막으로, 웹 API에 의해 구현된 일부 작업을 특정 리소스에 매핑하지 못할 수
                                    있습니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-197">Finally, it might
                                        not be possible to map every operation implemented by a web API to a specific
                                        resource.</span></span> <span data-ttu-id="1422d-198">HTTP GET 요청을 통해 기능을 호출하고
                                    결과를 HTTP 응답 메시지로 반환하는 <em>리소스가 아닌</em> 시나리오를 처리할 수 있습니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-198">You can handle such
                                        <em>non-resource</em> scenarios through HTTP requests that invoke a function and
                                        return the results as an HTTP response message.</span></span> <span
                                    data-ttu-id="1422d-199">예를 들어 더하기 및 빼기 같은 단순한 계산기 작업을 구현하는 Web API는 이러한 작업을 의사 리소스로
                                    표시하고 쿼리 문자열을 사용하여 필요한 매개 변수를 지정하는 URI를 제공할 수 있습니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-199">For example, a web API that
                                        implements simple calculator operations such as add and subtract could provide
                                        URIs that expose these operations as pseudo resources and use the query string
                                        to specify the parameters required.</span></span> <span
                                    data-ttu-id="1422d-200">예를 들어 <em>URI/add?operand1=99&amp;operand2=1에</em> 대한 GET
                                    요청은 값 100을 포함하는 본문에 응답 메시지를 반환합니다.</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-200">For example, a GET request to the URI
                                        <em>/add?operand1=99&amp;operand2=1</em> would return a response message with
                                        the body containing the value 100.</span></span> <span
                                    data-ttu-id="1422d-201">그러나 이러한 형식의 URI는 제한적으로만 사용해야 합니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-201">However, only use these forms of
                                        URIs sparingly.</span></span></p>
                            <h2 id="define-operations-in-terms-of-http-methods"><span data-ttu-id="1422d-202">HTTP 메서드를
                                    기준으로 작업 정의</span><span class="sxs-lookup"><span data-stu-id="1422d-202">Define
                                        operations in terms of HTTP methods</span></span></h2>
                            <p><span data-ttu-id="1422d-203">HTTP 프로토콜은 요청에 의미 체계의미를 할당하는 다양한 메서드를 정의합니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-203">The HTTP protocol defines a number
                                        of methods that assign semantic meaning to a request.</span></span> <span
                                    data-ttu-id="1422d-204">대부분의 RESTful 웹 API에서 사용하는 일반적인 HTTP 메서드는 다음과
                                    같습니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-204">The common HTTP
                                        methods used by most RESTful web APIs are:</span></span></p>
                            <ul>
                                <li><span data-ttu-id="1422d-205"><strong>GET</strong>은 지정된 URI에서 리소스의 표현을
                                        검색합니다.</span><span class="sxs-lookup"><span
                                            data-stu-id="1422d-205"><strong>GET</strong> retrieves a representation of
                                            the resource at the specified URI.</span></span> <span
                                        data-ttu-id="1422d-206">응답 메시지의 본문은 요청된 리소스의 세부 정보를 포함하고 있습니다.</span><span
                                        class="sxs-lookup"><span data-stu-id="1422d-206">The body of the response
                                            message contains the details of the requested resource.</span></span></li>
                                <li><span data-ttu-id="1422d-207"><strong>POST</strong>는 지정된 URI에 새 리소스를
                                        만듭니다.</span><span class="sxs-lookup"><span
                                            data-stu-id="1422d-207"><strong>POST</strong> creates a new resource at the
                                            specified URI.</span></span> <span data-ttu-id="1422d-208">요청 메시지의 본문은 새
                                        리소스의 세부 정보를 제공합니다.</span><span class="sxs-lookup"><span
                                            data-stu-id="1422d-208">The body of the request message provides the details
                                            of the new resource.</span></span> <span data-ttu-id="1422d-209">참고로 POST를
                                        사용하여 실제로 리소스를 만들지 않는 작업을 트리거할 수도 있습니다.</span><span class="sxs-lookup"><span
                                            data-stu-id="1422d-209">Note that POST can also be used to trigger
                                            operations that don't actually create resources.</span></span></li>
                                <li><span data-ttu-id="1422d-210"><strong>PUT</strong>은 지정된 URI에 리소스를 만들거나
                                        대체합니다.</span><span class="sxs-lookup"><span
                                            data-stu-id="1422d-210"><strong>PUT</strong> either creates or replaces the
                                            resource at the specified URI.</span></span> <span
                                        data-ttu-id="1422d-211">요청 메시지의 본문은 만들 또는 업데이트할 리소스를 지정합니다.</span><span
                                        class="sxs-lookup"><span data-stu-id="1422d-211">The body of the request message
                                            specifies the resource to be created or updated.</span></span></li>
                                <li><span data-ttu-id="1422d-212"><strong>PATCH</strong>는 리소스의 부분 업데이트를
                                        수행합니다.</span><span class="sxs-lookup"><span
                                            data-stu-id="1422d-212"><strong>PATCH</strong> performs a partial update of
                                            a resource.</span></span> <span data-ttu-id="1422d-213">요청 본문은 리소스에 적용할 변경
                                        내용을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-213">The
                                            request body specifies the set of changes to apply to the
                                            resource.</span></span></li>
                                <li><span data-ttu-id="1422d-214"><strong>DELETE</strong>는 지정된 URI의 리소스를
                                        제거합니다.</span><span class="sxs-lookup"><span
                                            data-stu-id="1422d-214"><strong>DELETE</strong> removes the resource at the
                                            specified URI.</span></span></li>
                            </ul>
                            <p><span data-ttu-id="1422d-215">특정 요청의 효과는 리소스가 컬렉션인지 아니면 개별 항목인지에 따라 달라집니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-215">The effect of a specific request
                                        should depend on whether the resource is a collection or an individual
                                        item.</span></span> <span data-ttu-id="1422d-216">다음 표는 전자 상거래 예제를 사용하여 대부분의
                                    RESTful 구현에서 채택한 일반적인 규칙을 요약합니다.</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-216">The following table summarizes the common conventions
                                        adopted by most RESTful implementations using the e-commerce
                                        example.</span></span> <span data-ttu-id="1422d-217">이러한 요청 중 일부가—구현되지 는 않지만 특정
                                    시나리오에 따라 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-217">Not all
                                        of these requests might be implemented—it depends on the specific
                                        scenario.</span></span></p>
                            <table>
                                <thead>
                                    <tr>
                                        <th><span data-ttu-id="1422d-218"><strong>리소스</strong></span><span
                                                class="sxs-lookup"><span
                                                    data-stu-id="1422d-218"><strong>Resource</strong></span></span></th>
                                        <th><span data-ttu-id="1422d-219"><strong>올리기</strong></span><span
                                                class="sxs-lookup"><span
                                                    data-stu-id="1422d-219"><strong>POST</strong></span></span></th>
                                        <th><span data-ttu-id="1422d-220"><strong>가져오기</strong></span><span
                                                class="sxs-lookup"><span
                                                    data-stu-id="1422d-220"><strong>GET</strong></span></span></th>
                                        <th><span data-ttu-id="1422d-221"><strong>넣어</strong></span><span
                                                class="sxs-lookup"><span
                                                    data-stu-id="1422d-221"><strong>PUT</strong></span></span></th>
                                        <th><span data-ttu-id="1422d-222"><strong>삭제</strong></span><span
                                                class="sxs-lookup"><span
                                                    data-stu-id="1422d-222"><strong>DELETE</strong></span></span></th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><span data-ttu-id="1422d-223">/customers</span><span
                                                class="sxs-lookup"><span
                                                    data-stu-id="1422d-223">/customers</span></span></td>
                                        <td><span data-ttu-id="1422d-224">새 고객 만들기</span><span class="sxs-lookup"><span
                                                    data-stu-id="1422d-224">Create a new customer</span></span></td>
                                        <td><span data-ttu-id="1422d-225">모든 고객 검색</span><span class="sxs-lookup"><span
                                                    data-stu-id="1422d-225">Retrieve all customers</span></span></td>
                                        <td><span data-ttu-id="1422d-226">고객 대량 업데이트</span><span
                                                class="sxs-lookup"><span data-stu-id="1422d-226">Bulk update of
                                                    customers</span></span></td>
                                        <td><span data-ttu-id="1422d-227">모든 고객 제거</span><span class="sxs-lookup"><span
                                                    data-stu-id="1422d-227">Remove all customers</span></span></td>
                                    </tr>
                                    <tr>
                                        <td><span data-ttu-id="1422d-228">/customers/1</span><span
                                                class="sxs-lookup"><span
                                                    data-stu-id="1422d-228">/customers/1</span></span></td>
                                        <td><span data-ttu-id="1422d-229">Error</span><span class="sxs-lookup"><span
                                                    data-stu-id="1422d-229">Error</span></span></td>
                                        <td><span data-ttu-id="1422d-230">고객 1에 대한 세부 정보 검색</span><span
                                                class="sxs-lookup"><span data-stu-id="1422d-230">Retrieve the details
                                                    for customer 1</span></span></td>
                                        <td><span data-ttu-id="1422d-231">고객 1이 있는 경우 고객 1의 세부 정보 업데이트</span><span
                                                class="sxs-lookup"><span data-stu-id="1422d-231">Update the details of
                                                    customer 1 if it exists</span></span></td>
                                        <td><span data-ttu-id="1422d-232">고객 1 제거</span><span class="sxs-lookup"><span
                                                    data-stu-id="1422d-232">Remove customer 1</span></span></td>
                                    </tr>
                                    <tr>
                                        <td><span data-ttu-id="1422d-233">/customers/1/orders</span><span
                                                class="sxs-lookup"><span
                                                    data-stu-id="1422d-233">/customers/1/orders</span></span></td>
                                        <td><span data-ttu-id="1422d-234">고객 1에 대한 새 주문 만들기</span><span
                                                class="sxs-lookup"><span data-stu-id="1422d-234">Create a new order for
                                                    customer 1</span></span></td>
                                        <td><span data-ttu-id="1422d-235">고객 1에 대한 모든 주문 검색</span><span
                                                class="sxs-lookup"><span data-stu-id="1422d-235">Retrieve all orders for
                                                    customer 1</span></span></td>
                                        <td><span data-ttu-id="1422d-236">고객 1의 주문 대량 업데이트</span><span
                                                class="sxs-lookup"><span data-stu-id="1422d-236">Bulk update of orders
                                                    for customer 1</span></span></td>
                                        <td><span data-ttu-id="1422d-237">고객 1의 모든 주문 제거</span><span
                                                class="sxs-lookup"><span data-stu-id="1422d-237">Remove all orders for
                                                    customer 1</span></span></td>
                                    </tr>
                                </tbody>
                            </table>
                            <p><span data-ttu-id="1422d-238">POST, PUT 및 PATCH의 차이점을 구분하기 어려울 수 있습니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-238">The differences between POST, PUT,
                                        and PATCH can be confusing.</span></span></p>
                            <ul>
                                <li>
                                    <p><span data-ttu-id="1422d-239">POST 요청은 리소스를 만듭니다.</span><span
                                            class="sxs-lookup"><span data-stu-id="1422d-239">A POST request creates a
                                                resource.</span></span> <span data-ttu-id="1422d-240">서버는 새 리소스에 대한 URI를
                                            할당하고 클라이언트에 해당 URI를 반환합니다.</span><span class="sxs-lookup"><span
                                                data-stu-id="1422d-240">The server assigns a URI for the new resource,
                                                and returns that URI to the client.</span></span> <span
                                            data-ttu-id="1422d-241">REST 모델에서는 컬렉션에 POST 요청을 자주 적용합니다.</span><span
                                            class="sxs-lookup"><span data-stu-id="1422d-241">In the REST model, you
                                                frequently apply POST requests to collections.</span></span> <span
                                            data-ttu-id="1422d-242">새 리소스가 컬렉션에 추가됩니다.</span><span
                                            class="sxs-lookup"><span data-stu-id="1422d-242">The new resource is added
                                                to the collection.</span></span> <span data-ttu-id="1422d-243">POST 요청은
                                            새 리소스를 만들지 않고 기존 리소스에 처리할 데이터를 보내는데 사용할 수도 있습니다.</span><span
                                            class="sxs-lookup"><span data-stu-id="1422d-243">A POST request can also be
                                                used to submit data for processing to an existing resource, without any
                                                new resource being created.</span></span></p>
                                </li>
                                <li>
                                    <p><span data-ttu-id="1422d-244">PUT 요청은 리소스를 만들거나 <em>또는</em> 기존 리소스를
                                            업데이트합니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-244">A PUT
                                                request creates a resource <em>or</em> updates an existing
                                                resource.</span></span> <span data-ttu-id="1422d-245">클라이언트는 리소스의 URI를
                                            지정합니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-245">The
                                                client specifies the URI for the resource.</span></span> <span
                                            data-ttu-id="1422d-246">요청 본문에는 리소스의 완전한 표현이 포함됩니다.</span><span
                                            class="sxs-lookup"><span data-stu-id="1422d-246">The request body contains a
                                                complete representation of the resource.</span></span> <span
                                            data-ttu-id="1422d-247">이 URI를 사용하는 리소스가 이미 있으면 리소스가 대체됩니다.</span><span
                                            class="sxs-lookup"><span data-stu-id="1422d-247">If a resource with this URI
                                                already exists, it is replaced.</span></span> <span
                                            data-ttu-id="1422d-248">아직 없고 서버에서 리소스 만들기를 지원하는 경우 새 리소스가
                                            생성됩니다.</span><span class="sxs-lookup"><span
                                                data-stu-id="1422d-248">Otherwise a new resource is created, if the
                                                server supports doing so.</span></span> <span
                                            data-ttu-id="1422d-249">PUT 요청은 컬렉션보다는 특정 고객 같은 개별 항목인 리소스에 가장 자주
                                            적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-249">PUT
                                                requests are most frequently applied to resources that are individual
                                                items, such as a specific customer, rather than
                                                collections.</span></span> <span data-ttu-id="1422d-250">서버에서 PUT을 통한
                                            업데이트를 지원하지만 만들기는 지원하지 않을 수 있습니다.</span><span class="sxs-lookup"><span
                                                data-stu-id="1422d-250">A server might support updates but not creation
                                                via PUT.</span></span> <span data-ttu-id="1422d-251">PUT을 통한 만들기 지원 여부는
                                            리소스가 존재하기 전에 클라이언트가 의미 있는 방법으로 리소스에 URI를 할당할 수 있는지 여부에 따라 결정됩니다.</span><span
                                            class="sxs-lookup"><span data-stu-id="1422d-251">Whether to support creation
                                                via PUT depends on whether the client can meaningfully assign a URI to a
                                                resource before it exists.</span></span> <span
                                            data-ttu-id="1422d-252">할당할 수 없는 경우 POST를 사용하여 리소스를 만들고 PUT 또는 PATCH를 사용하여
                                            업데이트합니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-252">If
                                                not, then use POST to create resources and PUT or PATCH to
                                                update.</span></span></p>
                                </li>
                                <li>
                                    <p><span data-ttu-id="1422d-253">PATCH 요청은 기존 리소스에 <em>부분 업데이트</em>를
                                            수행합니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-253">A PATCH
                                                request performs a <em>partial update</em> to an existing
                                                resource.</span></span> <span data-ttu-id="1422d-254">클라이언트는 리소스의 URI를
                                            지정합니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-254">The
                                                client specifies the URI for the resource.</span></span> <span
                                            data-ttu-id="1422d-255">요청 본문은 리소스에 적용할 <em>변경 내용</em>을 지정합니다.</span><span
                                            class="sxs-lookup"><span data-stu-id="1422d-255">The request body specifies
                                                a set of <em>changes</em> to apply to the resource.</span></span> <span
                                            data-ttu-id="1422d-256">클라이언트가 리소스의 전체 표현이 아닌 변경 내용만 보내기 때문에 PUT을 사용하는 것보다 이
                                            방법이 더 효율적일 수 있습니다.</span><span class="sxs-lookup"><span
                                                data-stu-id="1422d-256">This can be more efficient than using PUT,
                                                because the client only sends the changes, not the entire representation
                                                of the resource.</span></span> <span data-ttu-id="1422d-257">또한 서버에서 리소스
                                            만들기를 지원하는 경우 기술적으로 PATCH는 새 리소스를 만들 수 있습니다(&quot;null&quot; 리소스에 대한 업데이트를
                                            지정하여).</span><span class="sxs-lookup"><span
                                                data-stu-id="1422d-257">Technically PATCH can also create a new resource
                                                (by specifying a set of updates to a &quot;null&quot; resource), if the
                                                server supports this.</span></span></p>
                                </li>
                            </ul>
                            <p><span data-ttu-id="1422d-258">PUT 요청은 idempotent여야 합니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-258">PUT requests must be
                                        idempotent.</span></span> <span data-ttu-id="1422d-259">클라이언트가 동일한 PUT 요청을 여러 번
                                    제출하는 경우 그 결과가 항상 같아야 합니다(같은 값을 사용하여 같은 리소스가 수정되므로).</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-259">If a client submits the same PUT
                                        request multiple times, the results should always be the same (the same resource
                                        will be modified with the same values).</span></span> <span
                                    data-ttu-id="1422d-260">POST 및 PATCH 요청이 반드시 idempotent가 된다는 보장은 없습니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-260">POST and PATCH requests are not
                                        guaranteed to be idempotent.</span></span></p>
                            <h2 id="conform-to-http-semantics"><span data-ttu-id="1422d-261">HTTP 의미 체계 준수</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-261">Conform to HTTP
                                        semantics</span></span></h2>
                            <p><span data-ttu-id="1422d-262">이 섹션에서는 HTTP 사양을 준수하는 API 디자인에 대한 몇 가지 일반적인 고려 사항을
                                    설명합니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-262">This section
                                        describes some typical considerations for designing an API that conforms to the
                                        HTTP specification.</span></span> <span data-ttu-id="1422d-263">그러나 가능한 모든 세부 정보
                                    또는 시나리오를 다루지는 않습니다.</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-263">However, it doesn't cover every possible detail or
                                        scenario.</span></span> <span data-ttu-id="1422d-264">궁금한 점은 HTTP 사양을
                                    참조하세요.</span><span class="sxs-lookup"><span data-stu-id="1422d-264">When in doubt,
                                        consult the HTTP specifications.</span></span></p>
                            <h3 id="media-types"><span data-ttu-id="1422d-265">미디어 유형</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-265">Media types</span></span></h3>
                            <p><span data-ttu-id="1422d-266">앞서 언급했듯이, 클라이언트와 서버는 리소스 표현을 교환합니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-266">As mentioned earlier, clients and
                                        servers exchange representations of resources.</span></span> <span
                                    data-ttu-id="1422d-267">예를 들어 POST 요청에서는 요청 본문에 만들 리소스의 표현이 포함됩니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-267">For example, in a POST request, the
                                        request body contains a representation of the resource to create.</span></span>
                                <span data-ttu-id="1422d-268">GET 요청에서는 응답 본문에 가져온 리소스의 표현이 포함됩니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-268">In a GET request, the response body
                                        contains a representation of the fetched resource.</span></span></p>
                            <p><span data-ttu-id="1422d-269">HTTP 프로토콜에서 형식은 MIME 유형이라고도 하는 <em>미디어 유형</em>을 사용하여
                                    지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-269">In the HTTP
                                        protocol, formats are specified through the use of <em>media types</em>, also
                                        called MIME types.</span></span> <span data-ttu-id="1422d-270">이진이 아닌 데이터의 경우
                                    대부분의 Web API는 JSON(미디어 유형 = 애플리케이션/json) 및 XML(미디어 유형 = 애플리케이션/xml)을
                                    지원합니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-270">For non-binary
                                        data, most web APIs support JSON (media type = application/json) and possibly
                                        XML (media type = application/xml).</span></span></p>
                            <p><span data-ttu-id="1422d-271">요청 또는 응답의 Content-Type 헤더는 표현 형식을 지정합니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-271">The Content-Type header in a
                                        request or response specifies the format of the representation.</span></span>
                                <span data-ttu-id="1422d-272">다음은 JSON 데이터를 포함하는 POST 요청의 예입니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-272">Here is an example of a POST
                                        request that includes JSON data:</span></span></p>
                            <pre><code class="lang-http">POST https://adventure-works.com/orders HTTP/1.1
Content-Type: application/json; charset=utf-8
Content-Length: 57

{&quot;Id&quot;:1,&quot;Name&quot;:&quot;Gizmo&quot;,&quot;Category&quot;:&quot;Widgets&quot;,&quot;Price&quot;:1.99}
</code></pre>
                            <p><span data-ttu-id="1422d-273">서버에서 미디어 유형을 지원하지 않으면 HTTP 상태 코드 415(지원되지 않는 미디어 유형)를 반환해야
                                    합니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-273">If the server
                                        doesn't support the media type, it should return HTTP status code 415
                                        (Unsupported Media Type).</span></span></p>
                            <p><span data-ttu-id="1422d-274">클라이언트 요청에는 클라이언트가 응답 메시지에서 서버로부터 받는 미디어 유형 목록을 포함하는 Accept
                                    헤더가 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-274">A
                                        client request can include an Accept header that contains a list of media types
                                        the client will accept from the server in the response message.</span></span>
                                <span data-ttu-id="1422d-275">다음은 그 예입니다.</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-275">For example:</span></span></p>
                            <pre><code class="lang-http">GET https://adventure-works.com/orders/2 HTTP/1.1
Accept: application/json
</code></pre>
                            <p><span data-ttu-id="1422d-276">서버가 나열된 미디어 유형 중 어떤 것도 일치시킬 수 없는 경우 HTTP 상태 코드 406(허용되지
                                    않음)을 반환해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-276">If the
                                        server cannot match any of the media type(s) listed, it should return HTTP
                                        status code 406 (Not Acceptable).</span></span></p>
                            <h3 id="get-methods"><span data-ttu-id="1422d-277">GET 메서드</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-277">GET methods</span></span></h3>
                            <p><span data-ttu-id="1422d-278">성공적인 GET 메서드는 일반적으로 HTTP 상태 코드 200(정상)를 반환합니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-278">A successful GET method typically
                                        returns HTTP status code 200 (OK).</span></span> <span
                                    data-ttu-id="1422d-279">리소스를 찾을 수 없는 경우 메서드가 404(찾을 수 없음)를 반환해야 합니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-279">If the resource cannot be found,
                                        the method should return 404 (Not Found).</span></span></p>
                            <h3 id="post-methods"><span data-ttu-id="1422d-280">POST 메서드</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-280">POST methods</span></span></h3>
                            <p><span data-ttu-id="1422d-281">POST 메서드는 새 리소스를 만드는 경우 HTTP 상태 코드 201(만들어짐)을
                                    반환합니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-281">If a POST method
                                        creates a new resource, it returns HTTP status code 201 (Created).</span></span>
                                <span data-ttu-id="1422d-282">새 리소스의 URI는 응답의 Location 헤더에 포함됩니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-282">The URI of the new resource is
                                        included in the Location header of the response.</span></span> <span
                                    data-ttu-id="1422d-283">응답 본문은 리소스의 표현을 포함합니다.</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-283">The response body contains a representation of the
                                        resource.</span></span></p>
                            <p><span data-ttu-id="1422d-284">이 메서드가 일부 처리를 수행하지만 새 리소스를 만들지 않는 경우 메서드는 HTTP 상태 코드 200을
                                    반환하고 작업의 결과를 응답 본문에 포함할 수 있습니다.</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-284">If the method does some processing but does not create a
                                        new resource, the method can return HTTP status code 200 and include the result
                                        of the operation in the response body.</span></span> <span
                                    data-ttu-id="1422d-285">또는 반환할 결과가 없으면 메서드가 응답 본문 없이 HTTP 상태 코드 204(내용 없음)를 반환할 수
                                    있습니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-285">Alternatively, if
                                        there is no result to return, the method can return HTTP status code 204 (No
                                        Content) with no response body.</span></span></p>
                            <p><span data-ttu-id="1422d-286">클라이언트가 잘못된 데이터를 요청에 배치하면 서버에서 HTTP 상태 코드 400(잘못된 요청)을 반환해야
                                    합니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-286">If the client puts
                                        invalid data into the request, the server should return HTTP status code 400
                                        (Bad Request).</span></span> <span data-ttu-id="1422d-287">응답 본문에는 오류에 대한 추가 정보
                                    또는 자세한 정보를 제공하는 URI 링크가 포함될 수 있습니다.</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-287">The response body can contain additional information
                                        about the error or a link to a URI that provides more details.</span></span></p>
                            <h3 id="put-methods"><span data-ttu-id="1422d-288">PUT 메서드</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-288">PUT methods</span></span></h3>
                            <p><span data-ttu-id="1422d-289">PUT 메서드는 POST 메서드와 마찬가지로 새 리소스를 만드는 경우 HTTP 상태 코드
                                    201(만들어짐)을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-289">If a
                                        PUT method creates a new resource, it returns HTTP status code 201 (Created), as
                                        with a POST method.</span></span> <span data-ttu-id="1422d-290">이 메서드는 기존 리소스를
                                    업데이트할 경우 200(정상) 또는 204(내용 없음)를 반환합니다.</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-290">If the method updates an existing resource, it returns
                                        either 200 (OK) or 204 (No Content).</span></span> <span
                                    data-ttu-id="1422d-291">상황에 따라 기존 리소스를 업데이트할 수 없는 경우도 있습니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-291">In some cases, it might not be
                                        possible to update an existing resource.</span></span> <span
                                    data-ttu-id="1422d-292">이 경우 HTTP 상태 코드 409(충돌)를 반환하는 방안을 고려해야 합니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-292">In that case, consider returning
                                        HTTP status code 409 (Conflict).</span></span></p>
                            <p><span data-ttu-id="1422d-293">컬렉션의 복수 리소스에 대한 업데이트를 일괄 처리할 수 있는 일괄 HTTP PUT 작업의 구현을 생각해
                                    보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-293">Consider
                                        implementing bulk HTTP PUT operations that can batch updates to multiple
                                        resources in a collection.</span></span> <span data-ttu-id="1422d-294">PUT 요청은
                                    컬렉션의 URI를 지정해야 하며, 요청 본문에 수정할 리소스의 세부 정보를 지정해야 합니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-294">The PUT request should specify the
                                        URI of the collection, and the request body should specify the details of the
                                        resources to be modified.</span></span> <span data-ttu-id="1422d-295">이 접근 방식은
                                    데이터 전송량을 줄이고 성능을 향상시킬 수 있습니다.</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-295">This approach can help to reduce chattiness and improve
                                        performance.</span></span></p>
                            <h3 id="patch-methods"><span data-ttu-id="1422d-296">PATCH 메서드</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-296">PATCH methods</span></span></h3>
                            <p><span data-ttu-id="1422d-297">클라이언트는 PATCH 요청을 사용하여 업데이트를 <em>패치 문서</em>의 형태로 기존 리소스에
                                    보냅니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-297">With a PATCH
                                        request, the client sends a set of updates to an existing resource, in the form
                                        of a <em>patch document</em>.</span></span> <span data-ttu-id="1422d-298">서버는 패치
                                    문서를 처리하여 업데이트를 수행합니다.</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-298">The server processes the patch document to perform the
                                        update.</span></span> <span data-ttu-id="1422d-299">패치 문서는 리소스 전체가 아니라 적용할 변경
                                    내용만 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-299">The patch
                                        document doesn't describe the whole resource, only a set of changes to
                                        apply.</span></span> <span data-ttu-id="1422d-300">PATCH 메서드에 대한 사양(<a
                                        href="https://tools.ietf.org/html/rfc5789" data-linktype="external">RFC
                                        5789</a>)은 패치 문서에 대한 특정 형식을 정의하지 않습니다.</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-300">The specification for the PATCH method (<a
                                            href="https://tools.ietf.org/html/rfc5789" data-linktype="external">RFC
                                            5789</a>) doesn't define a particular format for patch
                                        documents.</span></span> <span data-ttu-id="1422d-301">형식은 요청의 미디어 형식에서 유추해야
                                    합니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-301">The format must be
                                        inferred from the media type in the request.</span></span></p>
                            <p><span data-ttu-id="1422d-302">Web API에 대한 가장 일반적인 데이터 형식은 JSON일 것입니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-302">JSON is probably the most common
                                        data format for web APIs.</span></span> <span data-ttu-id="1422d-303">두 가지 주요
                                    JSON 기반 패치 형식으로 <em>JSON 패치</em> 및 <em>JSON 병합 패치</em>가 있습니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-303">There are two main JSON-based patch
                                        formats, called <em>JSON patch</em> and <em>JSON merge patch</em>.</span></span>
                            </p>
                            <p><span data-ttu-id="1422d-304">JSON 병합 패치는 비교적 간단합니다.</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-304">JSON merge patch is somewhat simpler.</span></span>
                                <span data-ttu-id="1422d-305">패치 문서는 원래 JSON 리소스와 동일한 구조를 갖지만 변경 또는 추가할 필드의 하위 집합만 포함하고
                                    있습니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-305">The patch
                                        document has the same structure as the original JSON resource, but includes just
                                        the subset of fields that should be changed or added.</span></span> <span
                                    data-ttu-id="1422d-306">또한 패치 문서에서 필드 값에 대해 <code>null</code>을 지정하여 필드를 삭제할 수
                                    있습니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-306">In addition, a
                                        field can be deleted by specifying <code>null</code> for the field value in the
                                        patch document.</span></span> <span data-ttu-id="1422d-307">(즉, 원래 리소스가 명시적 null
                                    값을 가질 수 있으면 병합 패치가 적합하지 않습니다.)</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-307">(That means merge patch is not suitable if the original
                                        resource can have explicit null values.)</span></span></p>
                            <p><span data-ttu-id="1422d-308">예를 들어 원래 리소스의 JSON 표현은 다음과 같습니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-308">For example, suppose the original
                                        resource has the following JSON representation:</span></span></p>
                            <pre><code class="lang-json">{
    &quot;name&quot;:&quot;gizmo&quot;,
    &quot;category&quot;:&quot;widgets&quot;,
    &quot;color&quot;:&quot;blue&quot;,
    &quot;price&quot;:10
}
</code></pre>
                            <p><span data-ttu-id="1422d-309">이 리소스에 가능한 JSON 병합 패치는 다음과 같습니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-309">Here is a possible JSON merge patch
                                        for this resource:</span></span></p>
                            <pre><code class="lang-json">{
    &quot;price&quot;:12,
    &quot;color&quot;:null,
    &quot;size&quot;:&quot;small&quot;
}
</code></pre>
                            <p><span data-ttu-id="1422d-310">이렇게 하면 서버가 <code>price</code>업데이트, <code>color</code>삭제
                                    <code>size</code>및 <code>name</code> <code>category</code> 추가 를 지시하지만 수정되지는
                                    않습니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-310">This tells the
                                        server to update <code>price</code>, delete <code>color</code>, and add
                                        <code>size</code>, while <code>name</code> and <code>category</code> are not
                                        modified.</span></span> <span data-ttu-id="1422d-311">JSON 병합 패치의 정확한 세부 정보는 <a
                                        href="https://tools.ietf.org/html/rfc7396" data-linktype="external">RFC
                                        7396</a>을 참조하세요.</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-311">For the exact details of JSON merge patch, see <a
                                            href="https://tools.ietf.org/html/rfc7396" data-linktype="external">RFC
                                            7396</a>.</span></span> <span data-ttu-id="1422d-312">JSON 병합 패치의 미디어 유형은
                                    <code>application/merge-patch+json</code>입니다.</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-312">The media type for JSON merge patch is
                                        <code>application/merge-patch+json</code>.</span></span></p>
                            <p><span data-ttu-id="1422d-313">원래 리소스가 명시적 null 값을 포함할 수 있으면 패치 문서에서 <code>null</code>이 갖는
                                    특별한 의미 때문에 병합 패치가 적합하지 않습니다.</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-313">Merge patch is not suitable if the original resource can
                                        contain explicit null values, due to the special meaning of <code>null</code> in
                                        the patch document.</span></span> <span data-ttu-id="1422d-314">또한 패치 문서는 서버에서
                                    업데이트를 적용할 순서를 지정하지 않습니다.</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-314">Also, the patch document doesn't specify the order that
                                        the server should apply the updates.</span></span> <span
                                    data-ttu-id="1422d-315">데이터 및 도메인에 따라 이것이 중요할 수도 있고 중요하지 않을 수도 있습니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-315">That may or may not matter,
                                        depending on the data and the domain.</span></span> <span
                                    data-ttu-id="1422d-316"><a href="https://tools.ietf.org/html/rfc6902"
                                        data-linktype="external">RFC 6902</a>에 정의된 JSON 패치는 좀 더 유연합니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-316">JSON patch, defined in <a
                                            href="https://tools.ietf.org/html/rfc6902" data-linktype="external">RFC
                                            6902</a>, is more flexible.</span></span> <span data-ttu-id="1422d-317">작업의
                                    결과로 적용할 변경 내용을 지정합니다.</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-317">It specifies the changes as a sequence of operations to
                                        apply.</span></span> <span data-ttu-id="1422d-318">작업에는 추가, 제거, 바꾸기, 복사 및 테스트(값의
                                    유효성 검사)가 포함됩니다.</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-318">Operations include add, remove, replace, copy, and test
                                        (to validate values).</span></span> <span data-ttu-id="1422d-319">JSON 패치의 미디어
                                    유형은 <code>application/json-patch+json</code>입니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-319">The media type for JSON patch is
                                        <code>application/json-patch+json</code>.</span></span></p>
                            <p><span data-ttu-id="1422d-320">다음은 적절한 HTTP 상태 코드와 함께 PATCH 요청을 처리할 때 발생할 수 있는 몇 가지 일반적인
                                    오류 조건입니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-320">Here are some
                                        typical error conditions that might be encountered when processing a PATCH
                                        request, along with the appropriate HTTP status code.</span></span></p>
                            <table>
                                <thead>
                                    <tr>
                                        <th><span data-ttu-id="1422d-321">오류 조건</span><span class="sxs-lookup"><span
                                                    data-stu-id="1422d-321">Error condition</span></span></th>
                                        <th><span data-ttu-id="1422d-322">HTTP 상태 코드</span><span
                                                class="sxs-lookup"><span data-stu-id="1422d-322">HTTP status
                                                    code</span></span></th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><span data-ttu-id="1422d-323">지원되지 않는 패치 문서 형식입니다.</span><span
                                                class="sxs-lookup"><span data-stu-id="1422d-323">The patch document
                                                    format isn't supported.</span></span></td>
                                        <td><span data-ttu-id="1422d-324">415(지원되지 않는 미디어 형식)</span><span
                                                class="sxs-lookup"><span data-stu-id="1422d-324">415 (Unsupported Media
                                                    Type)</span></span></td>
                                    </tr>
                                    <tr>
                                        <td><span data-ttu-id="1422d-325">패치 문서의 형식이 잘못되었습니다.</span><span
                                                class="sxs-lookup"><span data-stu-id="1422d-325">Malformed patch
                                                    document.</span></span></td>
                                        <td><span data-ttu-id="1422d-326">400(잘못된 요청)</span><span
                                                class="sxs-lookup"><span data-stu-id="1422d-326">400 (Bad
                                                    Request)</span></span></td>
                                    </tr>
                                    <tr>
                                        <td><span data-ttu-id="1422d-327">패치 문서가 유효하지만 현재 상태에서는 변경 내용을 리소스에 적용할 수
                                                없습니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-327">The
                                                    patch document is valid, but the changes can't be applied to the
                                                    resource in its current state.</span></span></td>
                                        <td><span data-ttu-id="1422d-328">409(충돌)</span><span class="sxs-lookup"><span
                                                    data-stu-id="1422d-328">409 (Conflict)</span></span></td>
                                    </tr>
                                </tbody>
                            </table>
                            <h3 id="delete-methods"><span data-ttu-id="1422d-329">DELETE 메서드</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-329">DELETE methods</span></span></h3>
                            <p><span data-ttu-id="1422d-330">삭제 작업이 성공하면 웹 서버는 프로세스가 성공적으로 처리되었지만 응답 본문에 추가 정보가 포함되지
                                    않았음을 나타내는 HTTP 204 상태 코드로 응답해야 합니다.</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-330">If the delete operation is successful, the web server
                                        should respond with HTTP status code 204, indicating that the process has been
                                        successfully handled, but that the response body contains no further
                                        information.</span></span> <span data-ttu-id="1422d-331">리소스가 없는 경우 웹 서버는 HTTP
                                    404(찾을 수 없음)를 반환할 수 있습니다.</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-331">If the resource doesn't exist, the web server can return
                                        HTTP 404 (Not Found).</span></span></p>
                            <h3 id="asynchronous-operations"><span data-ttu-id="1422d-332">비동기 작업</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-332">Asynchronous
                                        operations</span></span></h3>
                            <p><span data-ttu-id="1422d-333">경우에 따라 POST, PUT, PATCH 또는 DELETE 작업을 완료하는 데 시간이 걸리는 처리가
                                    필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-333">Sometimes a
                                        POST, PUT, PATCH, or DELETE operation might require processing that takes a
                                        while to complete.</span></span> <span data-ttu-id="1422d-334">처리 작업이 완료될 때까지
                                    기다렸다가 클라이언트에 응답을 보내는 경우 허용되지 않는 수준의 대기 시간이 발생할 수 있습니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-334">If you wait for completion before
                                        sending a response to the client, it may cause unacceptable
                                        latency.</span></span> <span data-ttu-id="1422d-335">이 경우 비동기 작업을 수행하는 방안을 고려해
                                    보아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-335">If so,
                                        consider making the operation asynchronous.</span></span> <span
                                    data-ttu-id="1422d-336">요청 처리가 수락되었지만 아직 완료되지 않았음을 나타내는 HTTP 상태 코드 202(수락됨)를
                                    반환합니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-336">Return HTTP
                                        status code 202 (Accepted) to indicate the request was accepted for processing
                                        but is not completed.</span></span></p>
                            <p><span data-ttu-id="1422d-337">클라이언트가 상태 엔드포인트를 폴링하여 상태를 모니터링할 수 있도록 비동기 요청의 상태를 반환하는
                                    엔드포인트를 표시해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-337">You
                                        should expose an endpoint that returns the status of an asynchronous request, so
                                        the client can monitor the status by polling the status endpoint.</span></span>
                                <span data-ttu-id="1422d-338">202 응답의 Location 헤더에 상태 엔드포인트의 URI를 포함합니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-338">Include the URI of the status
                                        endpoint in the Location header of the 202 response.</span></span> <span
                                    data-ttu-id="1422d-339">다음은 그 예입니다.</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-339">For example:</span></span></p>
                            <pre><code class="lang-http">HTTP/1.1 202 Accepted
Location: /api/status/12345
</code></pre>
                            <p><span data-ttu-id="1422d-340">클라이언트가 이 엔드포인트에 GET 요청을 보내는 경우 응답에 요청의 현재 상태가 포함되어야
                                    합니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-340">If the client
                                        sends a GET request to this endpoint, the response should contain the current
                                        status of the request.</span></span> <span data-ttu-id="1422d-341">필요에 따라 예상 완료
                                    시간 또는 작업 취소 링크를 포함할 수 있습니다.</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-341">Optionally, it could also include an estimated time to
                                        completion or a link to cancel the operation.</span></span></p>
                            <pre><code class="lang-http">HTTP/1.1 200 OK
Content-Type: application/json

{
    &quot;status&quot;:&quot;In progress&quot;,
    &quot;link&quot;: { &quot;rel&quot;:&quot;cancel&quot;, &quot;method&quot;:&quot;delete&quot;, &quot;href&quot;:&quot;/api/status/12345&quot; }
}
</code></pre>
                            <p><span data-ttu-id="1422d-342">비동기 작업에서 새 리소스를 만드는 경우 작업 완료 후 상태 엔드포인트에서 상태 코드 303(다른 항목
                                    보기)을 반환해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-342">If the
                                        asynchronous operation creates a new resource, the status endpoint should return
                                        status code 303 (See Other) after the operation completes.</span></span> <span
                                    data-ttu-id="1422d-343">303 응답에 새 리소스의 URI를 제공하는 Location 헤더를 포함합니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-343">In the 303 response, include a
                                        Location header that gives the URI of the new resource:</span></span></p>
                            <pre><code class="lang-http">HTTP/1.1 303 See Other
Location: /api/orders/12345
</code></pre>
                            <p><span data-ttu-id="1422d-344">자세한 내용은 <a href="../patterns/async-request-reply"
                                        data-linktype="relative-path">비동기 요청-회신 패턴을</a>참조하십시오.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-344">For more information, see <a
                                            href="../patterns/async-request-reply"
                                            data-linktype="relative-path">Asynchronous Request-Reply
                                            pattern</a>.</span></span></p>
                            <h2 id="filter-and-paginate-data"><span data-ttu-id="1422d-345">데이터 필터링 및 페이지
                                    매기기</span><span class="sxs-lookup"><span data-stu-id="1422d-345">Filter and paginate
                                        data</span></span></h2>
                            <p><span data-ttu-id="1422d-346">단일 URI를 통해 리소스 컬렉션을 표시하면 정보의 하위 집합만 필요할 때에도 애플리케이션이 대량의
                                    데이터를 가져올 수 있습니다.</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-346">Exposing a collection of resources through a single URI
                                        can lead to applications fetching large amounts of data when only a subset of
                                        the information is required.</span></span> <span data-ttu-id="1422d-347">예를 들어
                                    클라이언트 애플리케이션에서 비용이 특정 값을 초과하는 모든 주문을 찾아야 한다고 가정해 봅시다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-347">For example, suppose a client
                                        application needs to find all orders with a cost over a specific
                                        value.</span></span> <span data-ttu-id="1422d-348">클라이언트 응용 프로그램은
                                    <em>/orders</em> URI에서 모든 주문을 검색한 후 클라이언트 쪽에서 이러한 주문을 필터링할 것입니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-348">It might retrieve all orders from
                                        the <em>/orders</em> URI and then filter these orders on the client
                                        side.</span></span> <span data-ttu-id="1422d-349">이 프로세스는 매우
                                    비효율적입니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-349">Clearly this
                                        process is highly inefficient.</span></span> <span data-ttu-id="1422d-350">Web
                                    API를 호스팅하는 서버의 네트워크 대역폭 및 처리 성능이 낭비됩니다.</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-350">It wastes network bandwidth and processing power on the
                                        server hosting the web API.</span></span></p>
                            <p><span data-ttu-id="1422d-351">이 방법 대신, <em>/orders?minCost=n</em>처럼 API가 URI의 쿼리 문자열에서 필터
                                    전달을 허용할 수 있습니다.</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-351">Instead, the API can allow passing a filter in the query
                                        string of the URI, such as <em>/orders?minCost=n</em>.</span></span> <span
                                    data-ttu-id="1422d-352">그러면 Web API가 쿼리 문자열의 <code>minCost</code> 매개 변수를 구문 분석 및
                                    처리하고 서버 쪽에서 필터링된 결과를 반환합니다.</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-352">The web API is then responsible for parsing and handling
                                        the <code>minCost</code> parameter in the query string and returning the
                                        filtered results on the server side.</span></span></p>
                            <p><span data-ttu-id="1422d-353">컬렉션 리소스에 대한 GET 요청은 다수의 항목을 반환할 가능성이 있습니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-353">GET requests over collection
                                        resources can potentially return a large number of items.</span></span> <span
                                    data-ttu-id="1422d-354">단일 요청에서 반환하는 데이터의 양이 제한되도록 Web API를 디자인해야 합니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-354">You should design a web API to
                                        limit the amount of data returned by any single request.</span></span> <span
                                    data-ttu-id="1422d-355">검색할 최대 항목 수와 컬렉션의 시작 오프셋을 지정하는 쿼리 문자열을 지원하는 방안을 고려해
                                    봅니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-355">Consider
                                        supporting query strings that specify the maximum number of items to retrieve
                                        and a starting offset into the collection.</span></span> <span
                                    data-ttu-id="1422d-356">다음은 그 예입니다.</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-356">For example:</span></span></p>
                            <pre><code class="lang-http">/orders?limit=25&amp;offset=50
</code></pre>
                            <p><span data-ttu-id="1422d-357">또한 서비스 거부 공격을 방지하기 위해 반환되는 항목 수를 제한하는 방안도 고려해
                                    봅니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-357">Also consider
                                        imposing an upper limit on the number of items returned, to help prevent Denial
                                        of Service attacks.</span></span> <span data-ttu-id="1422d-358">클라이언트 애플리케이션을 돕기
                                    위해, 페이지가 매겨진 데이터를 반환하는 GET 요청은 컬렉션의 사용할 수 있는 총 리소스 수를 나타내는 모종의 메타데이터 형식을 포함해야
                                    합니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-358">To assist client
                                        applications, GET requests that return paginated data should also include some
                                        form of metadata that indicate the total number of resources available in the
                                        collection.</span></span></p>
                            <p><span data-ttu-id="1422d-359">필드 이름을 <em>/orders?sort=ProductID</em> 같은 값으로 가져오는 정렬 매개
                                    변수를 제공하여 데이터를 가져올 때 데이터를 정렬하는 비슷한 전략을 사용할 수 있습니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-359">You can use a similar strategy to
                                        sort data as it is fetched, by providing a sort parameter that takes a field
                                        name as the value, such as <em>/orders?sort=ProductID</em>.</span></span> <span
                                    data-ttu-id="1422d-360">그러나 쿼리 문자열 매개 변수는 여러 캐시 구현에서 캐시된 데이터의 키로 사용되는 리소스 식별자의 일부를
                                    구성하기 때문에 이 접근 방식은 캐싱에 나쁜 영향을 미칠 수 있습니다.</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-360">However, this approach can have a negative effect on
                                        caching, because query string parameters form part of the resource identifier
                                        used by many cache implementations as the key to cached data.</span></span></p>
                            <p><span data-ttu-id="1422d-361">각 항목에 대량의 데이터가 포함된 경우 각 항목에 대해 반환되는 필드를 제한하도록 이 접근 방식을 확장할
                                    수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-361">You can extend
                                        this approach to limit the fields returned for each item, if each item contains
                                        a large amount of data.</span></span> <span data-ttu-id="1422d-362">예를 들어 쉼표로
                                    구분된 필드 목록을 수락하는 <em>/orders?fields=ProductID,Quantity</em> 같은 쿼리 문자열 매개 변수를 사용할 수
                                    있습니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-362">For example, you
                                        could use a query string parameter that accepts a comma-delimited list of
                                        fields, such as <em>/orders?fields=ProductID,Quantity</em>.</span></span></p>
                            <p><span data-ttu-id="1422d-363">쿼리 문자열의 모든 선택적 매개 변수에 의미 있는 기본값을 제공합니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-363">Give all optional parameters in
                                        query strings meaningful defaults.</span></span> <span
                                    data-ttu-id="1422d-364">예를 들어 페이지 매김을 구현하는 경우 <code>limit</code> 매개 변수를 10으로,
                                    <code>offset</code> 매개 변수를 0으로 설정하고, 주문을 구현하는 경우 정렬 매개 변수를 리소스의 키로 설정하고, 프로젝션을 지원하는
                                    경우 <code>fields</code> 매개 변수를 리소스의 모든 필드로 설정합니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-364">For example, set the
                                        <code>limit</code> parameter to 10 and the <code>offset</code> parameter to 0 if
                                        you implement pagination, set the sort parameter to the key of the resource if
                                        you implement ordering, and set the <code>fields</code> parameter to all fields
                                        in the resource if you support projections.</span></span></p>
                            <h2 id="support-partial-responses-for-large-binary-resources"><span
                                    data-ttu-id="1422d-365">대용량 이진 리소스에 대한 부분 응답 지원</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-365">Support partial responses for large binary
                                        resources</span></span></h2>
                            <p><span data-ttu-id="1422d-366">리소스에 파일 또는 이미지 같은 대용량 이진 필드가 포함될 수 있습니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-366">A resource may contain large binary
                                        fields, such as files or images.</span></span> <span data-ttu-id="1422d-367">신뢰할
                                    수 없는 간헐적 연결에 의해 야기되는 문제를 해결하고 응답 시간을 개선하려면 이러한 리소스를 청크로 검색할 수 있게 하는 방안을 고려해
                                    보세요.</span><span class="sxs-lookup"><span data-stu-id="1422d-367">To overcome
                                        problems caused by unreliable and intermittent connections and to improve
                                        response times, consider enabling such resources to be retrieved in
                                        chunks.</span></span> <span data-ttu-id="1422d-368">이렇게 하려면 Web API가 큰 리소스의 GET
                                    요청에 대해 Accept-Ranges 헤더를 지원해야 합니다.</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-368">To do this, the web API should support the Accept-Ranges
                                        header for GET requests for large resources.</span></span> <span
                                    data-ttu-id="1422d-369">이 헤더는 GET 작업이 부분 요청을 지원한다는 것을 나타냅니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-369">This header indicates that the GET
                                        operation supports partial requests.</span></span> <span
                                    data-ttu-id="1422d-370">클라이언트 애플리케이션은 바이트 범위로 지정된 리소스 하위 집합을 반환하는 GET 요청을 제출할 수
                                    있습니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-370">The client
                                        application can submit GET requests that return a subset of a resource,
                                        specified as a range of bytes.</span></span></p>
                            <p><span data-ttu-id="1422d-371">또한 이러한 리소스에 대해 HTTP HEAD 요청을 구현하는 방안을 고려해 봅니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-371">Also, consider implementing HTTP
                                        HEAD requests for these resources.</span></span> <span
                                    data-ttu-id="1422d-372">HEAD 요청은 리소스에 대해 설명하는 HTTP 헤더만 반환하고 메시지 본문이 비어 있다는 점을 제외하면
                                    GET 요청과 비슷합니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-372">A HEAD
                                        request is similar to a GET request, except that it only returns the HTTP
                                        headers that describe the resource, with an empty message body.</span></span>
                                <span data-ttu-id="1422d-373">클라이언트 애플리케이션은 부분적인 GET 요청을 사용하여 리소스를 가져올지 여부를 결정하는 HEAD
                                    요청을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-373">A
                                        client application can issue a HEAD request to determine whether to fetch a
                                        resource by using partial GET requests.</span></span> <span
                                    data-ttu-id="1422d-374">다음은 그 예입니다.</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-374">For example:</span></span></p>
                            <pre><code class="lang-http">HEAD https://adventure-works.com/products/10?fields=productImage HTTP/1.1
</code></pre>
                            <p><span data-ttu-id="1422d-375">다음은 응답 메시지 예제입니다.</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-375">Here is an example response message:</span></span></p>
                            <pre><code class="lang-http">HTTP/1.1 200 OK

Accept-Ranges: bytes
Content-Type: image/jpeg
Content-Length: 4580
</code></pre>
                            <p><span data-ttu-id="1422d-376">Content-Length 헤더는 총 리소스 크기를 제공하고, Accept-Ranges 헤더는 해당 GET
                                    작업이 일부 결과를 지원함을 나타냅니다.</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-376">The Content-Length header gives the total size of the
                                        resource, and the Accept-Ranges header indicates that the corresponding GET
                                        operation supports partial results.</span></span> <span
                                    data-ttu-id="1422d-377">클라이언트 애플리케이션은 이 정보를 사용하여 더 작은 청크에서 이미지를 검색할 수
                                    있습니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-377">The client
                                        application can use this information to retrieve the image in smaller
                                        chunks.</span></span> <span data-ttu-id="1422d-378">첫 번째 요청은 범위 헤더를 사용하여 처음 2500
                                    바이트를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-378">The first
                                        request fetches the first 2500 bytes by using the Range header:</span></span>
                            </p>
                            <pre><code class="lang-http">GET https://adventure-works.com/products/10?fields=productImage HTTP/1.1
Range: bytes=0-2499
</code></pre>
                            <p><span data-ttu-id="1422d-379">응답 메시지는 HTTP 상태 코드 206을 반환하여 이 응답이 부분 응답임을
                                    나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-379">The response
                                        message indicates that this is a partial response by returning HTTP status code
                                        206.</span></span> <span data-ttu-id="1422d-380">Content-Length 헤더는 메시지 본문에 반환된
                                    실제 바이트 수(리소스의 크기가 아닌)를 지정하며, Content-Range 헤더는 해당 바이트가 리소스의 어느 부분인지(4580 바이트 중 바이트
                                    0-2499)를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-380">The
                                        Content-Length header specifies the actual number of bytes returned in the
                                        message body (not the size of the resource), and the Content-Range header
                                        indicates which part of the resource this is (bytes 0-2499 out of
                                        4580):</span></span></p>
                            <pre><code class="lang-http">HTTP/1.1 206 Partial Content

Accept-Ranges: bytes
Content-Type: image/jpeg
Content-Length: 2500
Content-Range: bytes 0-2499/4580

[...]
</code></pre>
                            <p><span data-ttu-id="1422d-381">클라이언트 애플리케이션의 후속 요청은 리소스의 나머지 부분을 검색할 수 있습니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-381">A subsequent request from the
                                        client application can retrieve the remainder of the resource.</span></span></p>
                            <h2 id="use-hateoas-to-enable-navigation-to-related-resources"><span
                                    data-ttu-id="1422d-382">HATEOAS를 사용하여 관련 리소스 탐색</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-382">Use HATEOAS to enable navigation to related
                                        resources</span></span></h2>
                            <p><span data-ttu-id="1422d-383">REST를 실행하는 기본적인 동기 중 하나는 URI 체계에 대해 미리 알고 있지 않아도 전체 리소스 집합을
                                    탐색할 수 있어야 하기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-383">One
                                        of the primary motivations behind REST is that it should be possible to navigate
                                        the entire set of resources without requiring prior knowledge of the URI
                                        scheme.</span></span> <span data-ttu-id="1422d-384">각 HTTP GET 요청은 응답에 포함된
                                    하이퍼링크를 통해 요청된 개체와 직접 관련된 리소스를 찾는 데 필요한 정보를 반환해야 하며, 이러한 각 리소스에 대해 사용할 수 있는 작업을 설명하는
                                    정보도 제공되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-384">Each
                                        HTTP GET request should return the information necessary to find the resources
                                        related directly to the requested object through hyperlinks included in the
                                        response, and it should also be provided with information that describes the
                                        operations available on each of these resources.</span></span> <span
                                    data-ttu-id="1422d-385">이 원칙을 HATEOAS(Hypertext as the Engine of Application State)라
                                    합니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-385">This principle is
                                        known as HATEOAS, or Hypertext as the Engine of Application State.</span></span>
                                <span data-ttu-id="1422d-386">시스템은 실질적으로 유한 상태 시스템으로서, 각 요청에 대한 응답은 한 상태에서 다른 상태로 바꾸는 데
                                    필요한 정보를 포함하고 있으며, 다른 정보는 필요하지 않습니다.</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-386">The system is effectively a finite state machine, and
                                        the response to each request contains the information necessary to move from one
                                        state to another; no other information should be necessary.</span></span></p>
                            <div class="NOTE">
                                <p>참고</p>
                                <p><span data-ttu-id="1422d-387">현재 HATEOAS 원칙을 모델링하는 방법을 정의하는 표준 또는 사양은
                                        없습니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-387">Currently
                                            there are no standards or specifications that define how to model the
                                            HATEOAS principle.</span></span> <span data-ttu-id="1422d-388">이 섹션에 나오는
                                        예제에서는 한 가지 가능한 해결 방법을 보여 줍니다.</span><span class="sxs-lookup"><span
                                            data-stu-id="1422d-388">The examples shown in this section illustrate one
                                            possible solution.</span></span></p>
                            </div>
                            <p><span data-ttu-id="1422d-389">예를 들어 주문과 고객 간의 관계를 처리하기 위해 주문 고객에게 사용 가능한 작업을 식별하는 링크를 주문
                                    표현에 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-389">For
                                        example, to handle the relationship between an order and a customer, the
                                        representation of an order could include links that identify the available
                                        operations for the customer of the order.</span></span> <span
                                    data-ttu-id="1422d-390">다음은 가능한 표현입니다.</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-390">Here is a possible representation:</span></span></p>
                            <pre><code class="lang-json">{
  &quot;orderID&quot;:3,
  &quot;productID&quot;:2,
  &quot;quantity&quot;:4,
  &quot;orderValue&quot;:16.60,
  &quot;links&quot;:[
    {
      &quot;rel&quot;:&quot;customer&quot;,
      &quot;href&quot;:&quot;https://adventure-works.com/customers/3&quot;,
      &quot;action&quot;:&quot;GET&quot;,
      &quot;types&quot;:[&quot;text/xml&quot;,&quot;application/json&quot;]
    },
    {
      &quot;rel&quot;:&quot;customer&quot;,
      &quot;href&quot;:&quot;https://adventure-works.com/customers/3&quot;,
      &quot;action&quot;:&quot;PUT&quot;,
      &quot;types&quot;:[&quot;application/x-www-form-urlencoded&quot;]
    },
    {
      &quot;rel&quot;:&quot;customer&quot;,
      &quot;href&quot;:&quot;https://adventure-works.com/customers/3&quot;,
      &quot;action&quot;:&quot;DELETE&quot;,
      &quot;types&quot;:[]
    },
    {
      &quot;rel&quot;:&quot;self&quot;,
      &quot;href&quot;:&quot;https://adventure-works.com/orders/3&quot;,
      &quot;action&quot;:&quot;GET&quot;,
      &quot;types&quot;:[&quot;text/xml&quot;,&quot;application/json&quot;]
    },
    {
      &quot;rel&quot;:&quot;self&quot;,
      &quot;href&quot;:&quot;https://adventure-works.com/orders/3&quot;,
      &quot;action&quot;:&quot;PUT&quot;,
      &quot;types&quot;:[&quot;application/x-www-form-urlencoded&quot;]
    },
    {
      &quot;rel&quot;:&quot;self&quot;,
      &quot;href&quot;:&quot;https://adventure-works.com/orders/3&quot;,
      &quot;action&quot;:&quot;DELETE&quot;,
      &quot;types&quot;:[]
    }]
}
</code></pre>
                            <p><span data-ttu-id="1422d-391">이 예에서 <code>links</code> 배열에는 링크 집합이 있습니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-391">In this example, the
                                        <code>links</code> array has a set of links.</span></span> <span
                                    data-ttu-id="1422d-392">각 링크는 관련 엔터티에 대한 작업을 나타냅니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-392">Each link represents an operation
                                        on a related entity.</span></span> <span data-ttu-id="1422d-393">각 링크의 데이터에는
                                    관계(&quot;고객&quot;), URI(<code>https://adventure-works.com/customers/3</code>), HTTP
                                    메서드 및 지원되는 MIME 형식이 포함됩니다.</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-393">The data for each link includes the relationship
                                        (&quot;customer&quot;), the URI
                                        (<code>https://adventure-works.com/customers/3</code>), the HTTP method, and the
                                        supported MIME types.</span></span> <span data-ttu-id="1422d-394">이 모든 정보가 있어야
                                    클라이언트 애플리케이션이 작업을 호출할 수 있습니다.</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-394">This is all the information that a client application
                                        needs to be able to invoke the operation.</span></span></p>
                            <p><span data-ttu-id="1422d-395">또한 <code>links</code> 배열은 검색된 리소스 자체에 대한 자체 참조 정보를
                                    포함합니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-395">The
                                        <code>links</code> array also includes self-referencing information about the
                                        resource itself that has been retrieved.</span></span> <span
                                    data-ttu-id="1422d-396">이러한 관계가 <em>자체</em> 관계입니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-396">These have the relationship
                                        <em>self</em>.</span></span></p>
                            <p><span data-ttu-id="1422d-397">리소스의 상태에 따라 반환되는 링크 집합이 달라질 수 있습니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-397">The set of links that are returned
                                        may change, depending on the state of the resource.</span></span> <span
                                    data-ttu-id="1422d-398">이것이 바로 &quot;애플리케이션 상태 엔진&quot;이라는 하이퍼텍스트가 의미하는
                                    바입니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-398">This is what is
                                        meant by hypertext being the &quot;engine of application
                                        state.&quot;</span></span></p>
                            <h2 id="versioning-a-restful-web-api"><span data-ttu-id="1422d-399">RESTful 웹 API 버전
                                    관리</span><span class="sxs-lookup"><span data-stu-id="1422d-399">Versioning a RESTful
                                        web API</span></span></h2>
                            <p><span data-ttu-id="1422d-400">Web API가 정적 상태를 유지할 가능성은 매우 낮습니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-400">It is highly unlikely that a web
                                        API will remain static.</span></span> <span data-ttu-id="1422d-401">비즈니스 요구 사항이
                                    변경됨에 따라 자원의 새 컬렉션이 추가될 수 있으므로, 리소스 간의 관계가 변할 수 있으며 리소스 데이터의 구조가 수정될 수
                                    있습니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-401">As business
                                        requirements change new collections of resources may be added, the relationships
                                        between resources might change, and the structure of the data in resources might
                                        be amended.</span></span> <span data-ttu-id="1422d-402">웹 API를 새로운 또는 서로 다른 요구
                                    사항을 처리하도록 업데이트하는 동안 해당 변경이 웹 API를 사용하는 클라이언트 애플리케이션에 미치는 영향을 고려해야 합니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-402">While updating a web API to handle
                                        new or differing requirements is a relatively straightforward process, you must
                                        consider the effects that such changes will have on client applications
                                        consuming the web API.</span></span> <span data-ttu-id="1422d-403">문제는 웹 API를
                                    디자인하고 구현하는 개발자가 해당 API를 완전히 제어할 수 있지만 개발자는 원격으로 운영하는 타사 조직에서 빌드할 수 있는 클라이언트 응용 프로그램에
                                    대한 동일한 수준의 제어 권한을 갖지 못한다는 것입니다.</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-403">The issue is that although the developer designing and
                                        implementing a web API has full control over that API, the developer does not
                                        have the same degree of control over client applications, which may be built by
                                        third-party organizations operating remotely.</span></span> <span
                                    data-ttu-id="1422d-404">따라서 새 클라이언트 애플리케이션이 새 기능과 리소스의 장점을 이용할 수 있도록 하면서도 기존 클라이언트
                                    애플리케이션이 변경되지 않고 계속 작동할 수 있도록 해야 합니다.</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-404">The primary imperative is to enable existing client
                                        applications to continue functioning unchanged while allowing new client
                                        applications to take advantage of new features and resources.</span></span></p>
                            <p><span data-ttu-id="1422d-405">버전 관리를 사용하면 웹 API는 자신이 표시하는 기능과 리소스를 나타낼 수 있으며, 클라이언트
                                    애플리케이션은 기능 또는 리소스의 특정 버전으로 지정된 요청을 제출할 수 있습니다.</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-405">Versioning enables a web API to indicate the features
                                        and resources that it exposes, and a client application can submit requests that
                                        are directed to a specific version of a feature or resource.</span></span> <span
                                    data-ttu-id="1422d-406">다음 섹션에서는 각각 자체의 이점과 절충점을 가지고 있는 다양한 접근 방식을
                                    설명합니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-406">The following
                                        sections describe several different approaches, each of which has its own
                                        benefits and trade-offs.</span></span></p>
                            <h3 id="no-versioning"><span data-ttu-id="1422d-407">버전 관리 없음</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-407">No versioning</span></span></h3>
                            <p><span data-ttu-id="1422d-408">가장 간단한 방법이며 일부 내부 API에 대해 허용될 수 있습니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-408">This is the simplest approach, and
                                        may be acceptable for some internal APIs.</span></span> <span
                                    data-ttu-id="1422d-409">중요한 변경 사항은 새 리소스 또는 새 링크로 나타낼 수 있습니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-409">Significant changes could be
                                        represented as new resources or new links.</span></span> <span
                                    data-ttu-id="1422d-410">기존 리소스에 콘텐츠를 추가해도 이 콘텐츠를 볼 것으로 예상되지 않는 클라이언트 응용 프로그램이 이를
                                    무시하기 때문에 주요 변경 내용이 나타나지 않을 수 있습니다.</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-410">Adding content to existing resources might not present a
                                        breaking change as client applications that are not expecting to see this
                                        content will ignore it.</span></span></p>
                            <p><span data-ttu-id="1422d-411">예를 들어 URI
                                    <code>https://adventure-works.com/customers/3</code>에 대한 요청은 클라이언트 애플리케이션이 예상하는
                                    <code>id</code>, <code>name</code> 및 <code>address</code> 필드가 포함된 단일 고객의 세부 정보를 반환해야
                                    합니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-411">For example, a
                                        request to the URI <code>https://adventure-works.com/customers/3</code> should
                                        return the details of a single customer containing <code>id</code>,
                                        <code>name</code>, and <code>address</code> fields expected by the client
                                        application:</span></span></p>
                            <pre><code class="lang-http">HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8

{&quot;id&quot;:3,&quot;name&quot;:&quot;Contoso LLC&quot;,&quot;address&quot;:&quot;1 Microsoft Way Redmond WA 98053&quot;}
</code></pre>
                            <div class="NOTE">
                                <p>참고</p>
                                <p><span data-ttu-id="1422d-412">간단한 설명을 위해 이 섹션에 표시된 예제 응답은 HATEOAS 링크를 포함하고 있지
                                        않습니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-412">For
                                            simplicity, the example responses shown in this section do not include
                                            HATEOAS links.</span></span></p>
                            </div>
                            <p><span data-ttu-id="1422d-413"><code>DateCreated</code> 필드가 고객 리소스의 체계에 추가되면 응답은 다음과
                                    같습니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-413">If the
                                        <code>DateCreated</code> field is added to the schema of the customer resource,
                                        then the response would look like this:</span></span></p>
                            <pre><code class="lang-http">HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8

{&quot;id&quot;:3,&quot;name&quot;:&quot;Contoso LLC&quot;,&quot;dateCreated&quot;:&quot;2014-09-04T12:11:38.0376089Z&quot;,&quot;address&quot;:&quot;1 Microsoft Way Redmond WA 98053&quot;}
</code></pre>
                            <p><span data-ttu-id="1422d-414">기존 클라이언트 애플리케이션은 인식되지 않은 필드를 무시할 수 있으면 계속 올바르게 작동할 수 있으며,
                                    한편 새 클라이언트 애플리케이션을 새 필드를 처리하도록 디자인할 수 있습니다.</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-414">Existing client applications might continue functioning
                                        correctly if they are capable of ignoring unrecognized fields, while new client
                                        applications can be designed to handle this new field.</span></span> <span
                                    data-ttu-id="1422d-415">그러나 리소스가 더 크게 변경되거나(필드 제거 또는 이름 변경 등) 리소스 간의 관계가 변경된 경우에는
                                    이러한 변화가 주요 변경 내용으로 인식되어 기존 클라이언트 애플리케이션이 올바르게 작동하지 못할 수 있습니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-415">However, if more radical changes to
                                        the schema of resources occur (such as removing or renaming fields) or the
                                        relationships between resources change then these may constitute breaking
                                        changes that prevent existing client applications from functioning
                                        correctly.</span></span> <span data-ttu-id="1422d-416">이러한 상황에서는 다음 방법 중 하나를
                                    고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-416">In these
                                        situations, you should consider one of the following approaches.</span></span>
                            </p>
                            <h3 id="uri-versioning"><span data-ttu-id="1422d-417">URI 버전 관리</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-417">URI versioning</span></span></h3>
                            <p><span data-ttu-id="1422d-418">웹 API를 수정하거나 리소스의 체계를 변경할 때마다 각 리소스의 URI에 버전 번호를
                                    추가합니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-418">Each time you
                                        modify the web API or change the schema of resources, you add a version number
                                        to the URI for each resource.</span></span> <span data-ttu-id="1422d-419">앞에서는
                                    기존 URI가 전과 같이 계속 작동하여 원래 체계를 준수하는 리소스를 반환해야 합니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-419">The previously existing URIs should
                                        continue to operate as before, returning resources that conform to their
                                        original schema.</span></span></p>
                            <p><span data-ttu-id="1422d-420">이전 예제를 확장하면 <code>address</code> 필드가 주소의 각 구성 부분을 포함하는 하위
                                    필드로 <code>streetAddress</code> <code>city</code>재구성되는 <code>zipCode</code>경우(예: 및)
                                    <code>https://adventure-works.com/v2/customers/3</code> <code>state</code>이 버전의 리소스는
                                    다음과 같은 버전 번호를 포함하는 URI를 통해 노출될 수 있습니다.</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-420">Extending the previous example, if the
                                        <code>address</code> field is restructured into subfields containing each
                                        constituent part of the address (such as <code>streetAddress</code>,
                                        <code>city</code>, <code>state</code>, and <code>zipCode</code>), this version
                                        of the resource could be exposed through a URI containing a version number, such
                                        as <code>https://adventure-works.com/v2/customers/3</code>:</span></span></p>
                            <pre><code class="lang-http">HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8

{&quot;id&quot;:3,&quot;name&quot;:&quot;Contoso LLC&quot;,&quot;dateCreated&quot;:&quot;2014-09-04T12:11:38.0376089Z&quot;,&quot;address&quot;:{&quot;streetAddress&quot;:&quot;1 Microsoft Way&quot;,&quot;city&quot;:&quot;Redmond&quot;,&quot;state&quot;:&quot;WA&quot;,&quot;zipCode&quot;:98053}}
</code></pre>
                            <p><span data-ttu-id="1422d-421">이 버전 관리 메커니즘은 매우 간단하지만 요청을 적절한 엔드포인트로 라우팅하는 서버에 따라
                                    달라집니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-421">This versioning
                                        mechanism is very simple but depends on the server routing the request to the
                                        appropriate endpoint.</span></span> <span data-ttu-id="1422d-422">그러나 여러 번 반복을
                                    통해 웹 API가 성숙해짐에 따라 이 메커니즘을 다룰 수 없게 될 수 있으며 서버가 다양한 버전을 지원해야 합니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-422">However, it can become unwieldy as
                                        the web API matures through several iterations and the server has to support a
                                        number of different versions.</span></span> <span data-ttu-id="1422d-423">또한
                                    순수주의자의 관점에서 모든 경우에 클라이언트 응용 프로그램이 동일한 데이터(고객 3)를 가져오므로 버전에 따라 URI가 실제로 달라서는 안
                                    됩니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-423">Also, from a
                                        purist's point of view, in all cases the client applications are fetching the
                                        same data (customer 3), so the URI should not really be different depending on
                                        the version.</span></span> <span data-ttu-id="1422d-424">또한 이 체계는 모든 링크가 자신의
                                    URI에 버전 번호를 포함해야 하므로 HATEOAS 구현을 복잡하게 만듭니다.</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-424">This scheme also complicates implementation of HATEOAS
                                        as all links will need to include the version number in their
                                        URIs.</span></span></p>
                            <h3 id="query-string-versioning"><span data-ttu-id="1422d-425">쿼리 문자열 버전 관리</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-425">Query string
                                        versioning</span></span></h3>
                            <p><span data-ttu-id="1422d-426">여러 URI를 제공하는 대신, HTTP 요청에 추가된 쿼리 문자열 내에
                                    <code>https://adventure-works.com/customers/3?version=2</code> 같은 매개 변수를 사용하여 리소스의
                                    버전을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-426">Rather
                                        than providing multiple URIs, you can specify the version of the resource by
                                        using a parameter within the query string appended to the HTTP request, such as
                                        <code>https://adventure-works.com/customers/3?version=2</code>.</span></span>
                                <span data-ttu-id="1422d-427">버전 매개 변수는 이전 클라이언트 애플리케이션에서 생략했다면 기본적으로 1과 같은 의미 있는
                                    값입니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-427">The version
                                        parameter should default to a meaningful value such as 1 if it is omitted by
                                        older client applications.</span></span></p>
                            <p><span data-ttu-id="1422d-428">이 접근 방식은 같은 리소스가 언제나 같은 URI에서 검색된다는 의미 체계 장점이 있지만, 쿼리 문자열을
                                    구문 분석하고 해당 HTTP 응답을 다시 보내기 위해 요청을 처리하는 코드에 따라 달라집니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-428">This approach has the semantic
                                        advantage that the same resource is always retrieved from the same URI, but it
                                        depends on the code that handles the request to parse the query string and send
                                        back the appropriate HTTP response.</span></span> <span
                                    data-ttu-id="1422d-429">또한 이 접근 방식은 HATEOAS를 URI 버전 관리 메커니즘으로 구현할 때와 같이
                                    복잡합니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-429">This approach
                                        also suffers from the same complications for implementing HATEOAS as the URI
                                        versioning mechanism.</span></span></p>
                            <div class="NOTE">
                                <p>참고</p>
                                <p><span data-ttu-id="1422d-430">일부 구형 웹 브라우저와 웹 프록시는 URI에 쿼리 문자열을 포함하는 요청에 대한 응답을 캐싱하지
                                        않습니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-430">Some older
                                            web browsers and web proxies will not cache responses for requests that
                                            include a query string in the URI.</span></span> <span
                                        data-ttu-id="1422d-431">이렇게 하면 웹 API를 사용하고 이러한 웹 브라우저 내에서 실행되는 웹 응용 프로그램의 성능이
                                        저하될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-431">This
                                            can degrade performance for web applications that use a web API and that run
                                            from within such a web browser.</span></span></p>
                            </div>
                            <h3 id="header-versioning"><span data-ttu-id="1422d-432">헤더 버전 관리</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-432">Header versioning</span></span>
                            </h3>
                            <p><span data-ttu-id="1422d-433">버전 번호를 쿼리 문자열 매개 변수로 추가하지 않고 리소스의 버전을 나타내는 사용자 지정 헤더를 구현할 수
                                    있습니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-433">Rather than
                                        appending the version number as a query string parameter, you could implement a
                                        custom header that indicates the version of the resource.</span></span> <span
                                    data-ttu-id="1422d-434">이 접근 방식을 사용하려면 클라이언트 애플리케이션이 적절한 헤더를 요청에 추가해야 하지만, version
                                    헤더가 생략된 경우 클라이언트 요청을 처리하는 코드가 기본값(버전 1)을 사용할 수 있습니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-434">This approach requires that the
                                        client application adds the appropriate header to any requests, although the
                                        code handling the client request could use a default value (version 1) if the
                                        version header is omitted.</span></span> <span data-ttu-id="1422d-435">다음 예제에서는
                                    <em>Custom-Header</em>라는 사용자 지정 헤더를 사용합니다.</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-435">The following examples use a custom header named
                                        <em>Custom-Header</em>.</span></span> <span data-ttu-id="1422d-436">이 헤더의 값은 웹
                                    API의 버전을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-436">The
                                        value of this header indicates the version of web API.</span></span></p>
                            <p><span data-ttu-id="1422d-437">버전 1:</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-437">Version 1:</span></span></p>
                            <pre><code class="lang-http">GET https://adventure-works.com/customers/3 HTTP/1.1
Custom-Header: api-version=1
</code></pre>
                            <pre><code class="lang-http">HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8

{&quot;id&quot;:3,&quot;name&quot;:&quot;Contoso LLC&quot;,&quot;address&quot;:&quot;1 Microsoft Way Redmond WA 98053&quot;}
</code></pre>
                            <p><span data-ttu-id="1422d-438">버전 2:</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-438">Version 2:</span></span></p>
                            <pre><code class="lang-http">GET https://adventure-works.com/customers/3 HTTP/1.1
Custom-Header: api-version=2
</code></pre>
                            <pre><code class="lang-http">HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8

{&quot;id&quot;:3,&quot;name&quot;:&quot;Contoso LLC&quot;,&quot;dateCreated&quot;:&quot;2014-09-04T12:11:38.0376089Z&quot;,&quot;address&quot;:{&quot;streetAddress&quot;:&quot;1 Microsoft Way&quot;,&quot;city&quot;:&quot;Redmond&quot;,&quot;state&quot;:&quot;WA&quot;,&quot;zipCode&quot;:98053}}
</code></pre>
                            <p><span data-ttu-id="1422d-439">이전 두 가지 방법과 마찬가지로 HATEOAS를 구현하려면 모든 링크에 적절한 사용자 지정 헤더를 포함해야
                                    합니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-439">As with the
                                        previous two approaches, implementing HATEOAS requires including the appropriate
                                        custom header in any links.</span></span></p>
                            <h3 id="media-type-versioning"><span data-ttu-id="1422d-440">미디어 형식 버전 관리</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-440">Media type versioning</span></span>
                            </h3>
                            <p><span data-ttu-id="1422d-441">이 지침의 앞부분에서 설명한 대로, 클라이언트 애플리케이션은 웹 서버에 HTTP GET 요청을 보낼 때
                                    Accept 헤더를 사용하여 처리할 수 있는 콘텐츠의 형식을 지정해야 합니다.</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-441">When a client application sends an HTTP GET request to a
                                        web server it should stipulate the format of the content that it can handle by
                                        using an Accept header, as described earlier in this guidance.</span></span>
                                <span data-ttu-id="1422d-442">흔히 <em>Accept</em> 헤더의 목적은 클라이언트 애플리케이션에서 응답 본문이 XML, JSON
                                    또는 클라이언트가 구문 분석할 수 있는 몇몇 다른 일반적인 형식 중 어느 형식인지 지정할 수 있도록 하는 것입니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-442">Frequently the purpose of the
                                        <em>Accept</em> header is to allow the client application to specify whether the
                                        body of the response should be XML, JSON, or some other common format that the
                                        client can parse.</span></span> <span data-ttu-id="1422d-443">그러나 클라이언트 애플리케이션이
                                    예상하는 리소스의 버전을 나타낼 수 있도록 하는 정보를 포함한 사용자 지정 미디어 형식을 정의할 수 있습니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-443">However, it is possible to define
                                        custom media types that include information enabling the client application to
                                        indicate which version of a resource it is expecting.</span></span> <span
                                    data-ttu-id="1422d-444">다음 예제는 <em>Accept</em> 헤더를 값
                                    <em>application/vnd.adventure-works.v1+json</em>과 함께 지정하는 요청을 나타냅니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-444">The following example shows a
                                        request that specifies an <em>Accept</em> header with the value
                                        <em>application/vnd.adventure-works.v1+json</em>.</span></span> <span
                                    data-ttu-id="1422d-445"><em>vnd.adventure-works.v1</em> 요소는 웹 서버에 대해 리소스의 버전 1을 반환해야
                                    한다는 것을 나타내며, 한편 <em>json</em> 요소는 응답 본문의 형식이 JSON이어야 함을 지정합니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-445">The <em>vnd.adventure-works.v1</em>
                                        element indicates to the web server that it should return version 1 of the
                                        resource, while the <em>json</em> element specifies that the format of the
                                        response body should be JSON:</span></span></p>
                            <pre><code class="lang-http">GET https://adventure-works.com/customers/3 HTTP/1.1
Accept: application/vnd.adventure-works.v1+json
</code></pre>
                            <p><span data-ttu-id="1422d-446">요청을 처리하는 코드는 <em>Accept</em> 헤더를 처리하고 가능하면 해당 헤더를 적용해야 합니다.
                                    클라이언트 애플리케이션은 <em>Accept</em> 헤더에 복수의 형식을 지정할 수 있으며, 이 경우 웹 서버는 응답 본문에 가장 적절한 형식을
                                    선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-446">The code
                                        handling the request is responsible for processing the <em>Accept</em> header
                                        and honoring it as far as possible (the client application may specify multiple
                                        formats in the <em>Accept</em> header, in which case the web server can choose
                                        the most appropriate format for the response body).</span></span> <span
                                    data-ttu-id="1422d-447">웹 서버는 Content-Type 헤더를 사용하여 응답 본문에 있는 데이터의 형식을
                                    확인합니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-447">The web server
                                        confirms the format of the data in the response body by using the Content-Type
                                        header:</span></span></p>
                            <pre><code class="lang-http">HTTP/1.1 200 OK
Content-Type: application/vnd.adventure-works.v1+json; charset=utf-8

{&quot;id&quot;:3,&quot;name&quot;:&quot;Contoso LLC&quot;,&quot;address&quot;:&quot;1 Microsoft Way Redmond WA 98053&quot;}
</code></pre>
                            <p><span data-ttu-id="1422d-448">Accept 헤더가 모든 알려진 미디어 형식을 지정하지 않은 경우, 웹 서버는 HTTP 406(승인 금지)
                                    응답 메시지를 생성하거나 기본 미디어 형식이 포함된 메시지를 반환할 수 있습니다.</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-448">If the Accept header does not specify any known media
                                        types, the web server could generate an HTTP 406 (Not Acceptable) response
                                        message or return a message with a default media type.</span></span></p>
                            <p><span data-ttu-id="1422d-449">이 접근 방식은 엄격히 말해서 버전 관리 메커니즘인지 여부에 대한 논란의 여지가 있으며 당연히 리소스
                                    링크에 관련 데이터의 MIME 형식을 포함할 수 있는 HATEOAS에 적합합니다.</span><span class="sxs-lookup"><span
                                        data-stu-id="1422d-449">This approach is arguably the purest of the versioning
                                        mechanisms and lends itself naturally to HATEOAS, which can include the MIME
                                        type of related data in resource links.</span></span></p>
                            <div class="NOTE">
                                <p>참고</p>
                                <p><span data-ttu-id="1422d-450">버전 관리 전략을 선택할 때에는 성능에 미치는 영향, 특히 웹 서버의 캐싱을 고려해야
                                        합니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-450">When you
                                            select a versioning strategy, you should also consider the implications on
                                            performance, especially caching on the web server.</span></span> <span
                                        data-ttu-id="1422d-451">URI 버전 관리 및 쿼리 문자열 버전 관리 체계는 같은 URI/쿼리 문자열 조합이 매번 같은
                                        데이터를 참조하므로 캐싱하기에 적합합니다.</span><span class="sxs-lookup"><span
                                            data-stu-id="1422d-451">The URI versioning and Query String versioning
                                            schemes are cache-friendly inasmuch as the same URI/query string combination
                                            refers to the same data each time.</span></span></p>
                                <p><span data-ttu-id="1422d-452">일반적으로 헤더 버전 관리 및 미디어 형식 버전 관리 메커니즘에는 사용자 지정 헤더 또는
                                        Accept 헤더의 값을 검사하기 위해 추가 논리가 필요합니다.</span><span class="sxs-lookup"><span
                                            data-stu-id="1422d-452">The Header versioning and Media Type versioning
                                            mechanisms typically require additional logic to examine the values in the
                                            custom header or the Accept header.</span></span> <span
                                        data-ttu-id="1422d-453">대규모 환경의 경우, 서로 다른 버전의 웹 API를 사용하는 많은 클라이언트가 서버 쪽 캐시에 상당한
                                        양의 중복된 데이터를 발생시킬 수 있습니다.</span><span class="sxs-lookup"><span
                                            data-stu-id="1422d-453">In a large-scale environment, many clients using
                                            different versions of a web API can result in a significant amount of
                                            duplicated data in a server-side cache.</span></span> <span
                                        data-ttu-id="1422d-454">클라이언트 애플리케이션이 캐싱을 구현하는 프록시를 통해 웹 서버와 통신하는 경우 이 문제가 심각할 수
                                        있으며, 현재 요청된 데이터의 복사본을 자체의 캐시에 저장하지 않은 경우에만 요청을 웹 서버에 전달해야 합니다.</span><span
                                        class="sxs-lookup"><span data-stu-id="1422d-454">This issue can become acute if
                                            a client application communicates with a web server through a proxy that
                                            implements caching, and that only forwards a request to the web server if it
                                            does not currently hold a copy of the requested data in its
                                            cache.</span></span></p>
                            </div>
                            <h2 id="open-api-initiative"><span data-ttu-id="1422d-455">Open API Initiative</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-455">Open API Initiative</span></span>
                            </h2>
                            <p><span data-ttu-id="1422d-456"><a href="https://www.openapis.org"
                                        data-linktype="external">Open API Initiative</a>는 공급업체에서 REST API 설명을 표준화하기 위해
                                    업계 컨소시엄에서 만들었습니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-456">The
                                        <a href="https://www.openapis.org" data-linktype="external">Open API
                                            Initiative</a> was created by an industry consortium to standardize REST API
                                        descriptions across vendors.</span></span> <span data-ttu-id="1422d-457">이
                                    이니셔티브의 일부로, Swagger 2.0 사양의 명칭이 OAS(Open API Specification)로 바뀐 후 Open API
                                    Initiative에 추가되었습니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-457">As
                                        part of this initiative, the Swagger 2.0 specification was renamed the OpenAPI
                                        Specification (OAS) and brought under the Open API Initiative.</span></span></p>
                            <p><span data-ttu-id="1422d-458">사용하는 웹 API에 OpenAPI를 채택할 수도 있습니다.</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-458">You may want to adopt OpenAPI for
                                        your web APIs.</span></span> <span data-ttu-id="1422d-459">몇 가지 고려할 점은 다음과
                                    같습니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-459">Some points to
                                        consider:</span></span></p>
                            <ul>
                                <li>
                                    <p><span data-ttu-id="1422d-460">OpenAPI 사양에는 REST API 디자인 방식에 대한 독자적인 지침이 포함되어
                                            있습니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-460">The
                                                OpenAPI Specification comes with a set of opinionated guidelines on how
                                                a REST API should be designed.</span></span> <span
                                            data-ttu-id="1422d-461">이 사양은 상호 운용성 측면에서는 이점이 있지만, 사양에 맞게 API를 디자인할 때는 좀 더
                                            주의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-461">That
                                                has advantages for interoperability, but requires more care when
                                                designing your API to conform to the specification.</span></span></p>
                                </li>
                                <li>
                                    <p><span data-ttu-id="1422d-462">OpenAPI는 구현 우선 방식이 아닌, 계약 우선 방식을 권장합니다.</span><span
                                            class="sxs-lookup"><span data-stu-id="1422d-462">OpenAPI promotes a
                                                contract-first approach, rather than an implementation-first
                                                approach.</span></span> <span data-ttu-id="1422d-463">계약 우선 방식에서는 API
                                            계약(인터페이스)을 먼저 디자인한 후 계약을 구현하는 코드를 작성합니다.</span><span
                                            class="sxs-lookup"><span data-stu-id="1422d-463">Contract-first means you
                                                design the API contract (the interface) first and then write code that
                                                implements the contract.</span></span></p>
                                </li>
                                <li>
                                    <p><span data-ttu-id="1422d-464">Swagger와 같은 도구는 API 계약에서 클라이언트 라이브러리 또는 문서를 생성할 수
                                            있습니다.</span><span class="sxs-lookup"><span data-stu-id="1422d-464">Tools
                                                like Swagger can generate client libraries or documentation from API
                                                contracts.</span></span> <span data-ttu-id="1422d-465">예를 들어 <a
                                                href="/ko-kr/aspnet/core/tutorials/web-api-help-pages-using-swagger"
                                                data-linktype="absolute-path">Swagger</a>를 사용하여 웹 API 도움말 페이지를 ASP.NET
                                            참조하세요.</span><span class="sxs-lookup"><span data-stu-id="1422d-465">For
                                                example, see <a
                                                    href="/ko-kr/aspnet/core/tutorials/web-api-help-pages-using-swagger"
                                                    data-linktype="absolute-path">ASP.NET Web API help pages using
                                                    Swagger</a>.</span></span></p>
                                </li>
                            </ul>
                            <h2 id="more-information"><span data-ttu-id="1422d-466">자세한 정보</span><span
                                    class="sxs-lookup"><span data-stu-id="1422d-466">More information</span></span></h2>
                            <ul>
                                <li>
                                    <p><span data-ttu-id="1422d-467"><a
                                                href="https://github.com/Microsoft/api-guidelines/blob/master/Guidelines.md"
                                                data-linktype="external">마이크로 소프트 REST API 가이드 라인 .</a></span><span
                                            class="sxs-lookup"><span data-stu-id="1422d-467"><a
                                                    href="https://github.com/Microsoft/api-guidelines/blob/master/Guidelines.md"
                                                    data-linktype="external">Microsoft REST API
                                                    guidelines</a>.</span></span> <span data-ttu-id="1422d-468">공용 REST
                                            API 디자인에 대한 구체적인 권장 사항입니다.</span><span class="sxs-lookup"><span
                                                data-stu-id="1422d-468">Detailed recommendations for designing public
                                                REST APIs.</span></span></p>
                                </li>
                                <li>
                                    <p><span data-ttu-id="1422d-469"><a
                                                href="https://mathieu.fenniak.net/the-api-checklist"
                                                data-linktype="external">웹 API 검사 목록</a>.</span><span
                                            class="sxs-lookup"><span data-stu-id="1422d-469"><a
                                                    href="https://mathieu.fenniak.net/the-api-checklist"
                                                    data-linktype="external">Web API checklist</a>.</span></span> <span
                                            data-ttu-id="1422d-470">Web API를 디자인 및 구현할 때 고려해야 하는 항목 목록입니다.</span><span
                                            class="sxs-lookup"><span data-stu-id="1422d-470">A useful list of items to
                                                consider when designing and implementing a web API.</span></span></p>
                                </li>
                                <li>
                                    <p><span data-ttu-id="1422d-471"><a href="https://www.openapis.org"
                                                data-linktype="external">API 이니셔티브를 엽니다.</a></span><span
                                            class="sxs-lookup"><span data-stu-id="1422d-471"><a
                                                    href="https://www.openapis.org" data-linktype="external">Open API
                                                    Initiative</a>.</span></span> <span data-ttu-id="1422d-472">Open
                                            API에 대한 설명서 및 구현 세부 정보입니다.</span><span class="sxs-lookup"><span
                                                data-stu-id="1422d-472">Documentation and implementation details on Open
                                                API.</span></span></p>
                                </li>
                            </ul>

                            <!-- </content> -->

                        </main>

                        <!-- recommended content page section -->

                        <nav data-bi-name="recommendation-bottom" hidden id="recommended-content-center"
                            class="is-hidden-desktop" aria-labelledby="recommended-content-center-title">
                            <h3 id="recommended-content-center-title"
                                class="is-size-2 has-margin-top-large has-margin-bottom-small">관련 문서</h3>
                        </nav>

                        <!-- end recommended content page section -->

                        <!-- page rating section -->
                        <div class="is-hidden-desktop has-border-top has-margin-top-large has-padding-top-small">


                            <div class="feedback-verbatim has-border-bottom has-padding-bottom-small has-margin-bottom-small"
                                data-bi-name="rating">
                                <div class="binary-rating">
                                    <div class="binary-rating-buttons">
                                        <h3
                                            class="has-text-weight-semibold has-margin-top-none has-margin-bottom-small">
                                            이 페이지가 도움이 되었나요?</h3>
                                        <div>
                                            <button
                                                class="thumb-rating like has-inner-focus has-padding-left-extra-small has-padding-right-extra-small"
                                                title="Yes" data-bi-name="rating-yes" aria-expanded="false"
                                                data-bi-sat="1" aria-controls="rating-container-mobile">
                                                <span aria-hidden="true" class="icon docon docon-like"></span>
                                                <span>Yes</span>
                                            </button>
                                            <button
                                                class="thumb-rating dislike has-inner-focus has-padding-none has-padding-right-extra-small"
                                                title="No" data-bi-name="rating-no" data-bi-sat="0"
                                                aria-expanded="false" aria-controls="rating-container-mobile">
                                                <span aria-hidden="true" class="icon docon docon-dislike"></span>
                                                <span>No</span>
                                            </button>
                                        </div>
                                    </div>
                                    <form class="feedback-verbatim-form is-hidden" id="rating-container-mobile">
                                        <div
                                            class="verbatim-textarea box is-relative has-box-shadow-none has-border has-margin-top-small has-padding-extra-small is-size-8">
                                            <label for="rating-textarea-mobile" class="visually-hidden">추가 피드백이
                                                있습니까?</label>
                                            <textarea id="rating-textarea-mobile" rows="4" maxlength="999"
                                                placeholder="추가 피드백이 있습니까?" required
                                                class="textarea has-border-none has-box-shadow-none has-inner-focus"></textarea>
                                        </div>
                                        <div
                                            class="buttons is-right has-margin-top-medium has-margin-right-extra-small">
                                            <button class="skip-rating button is-text is-link is-small"
                                                type="button">건너뛰기</button>
                                            <button class="submit-rating button is-primary is-small"
                                                data-bi-name="rating-verbatim" disabled type="submit">전송</button>
                                        </div>
                                    </form>
                                </div>
                                <div class="thankyou-rating is-hidden" tabindex="-1">
                                    <a id="abcdefghijklmn">감사합니다.</a>
                                </div>
                            </div>
                        </div>
                        <!-- end page rating section -->


                        <!-- feedback section -->
                        <section class="feedback-section is-relative" data-bi-name="feedback-section">

                            <h2 id="feedback" class="is-size-2 has-margin-top-large">피드백</h2>

                            <div class="alert choose-feedback-type has-margin-top-small has-margin-bottom-none">
                                <p aria-hidden="true" id="send-feedback-about"
                                    class="has-margin-top-none has-margin-bottom-none">다음에 대한 사용자 의견 제출 및 보기</p>

                                <div class="choose-feedback-buttons has-margin-top-large has-margin-bottom-none">

                                    <a class="button feedback-type-product has-margin-bottom-small github-link"
                                        aria-label="이 페이지에 대한 피드백 보내기" data-bi-name="create-issue-on-github">
                                        <span aria-hidden="true"
                                            class="docon docon-brand-github has-padding-right-extra-small"></span>
                                        <span>이 페이지</span>
                                    </a>
                                </div>
                            </div>

                            <div
                                class="action-container is-flex has-flex-justify-content-end has-margin-top-small has-margin-bottom-small">
                                <a class="view-on-github" data-bi-name="view-on-github"
                                    href="https://github.com/MicrosoftDocs/architecture-center.ko-kr/issues">
                                    <span aria-hidden="true" class="docon docon-brand-github"></span>
                                    <span>모든 페이지 피드백 보기</span>
                                    <span aria-hidden="true"
                                        class="icon docon docon-navigate-external is-size-3"></span>
                                </a>
                            </div>
                        </section>

                        <!-- end feedback section -->

                        <!-- feedback report section -->
                        <!-- end feedback report section -->

                        <div class="footerContainer is-visible-interactive has-default-focus ">
                            <footer id="footer-interactive" data-bi-name="footer" class="footer-layout">

                                <div class="is-flex is-full-height has-padding-right-extra-large-desktop">
                                    <a data-mscc-ic="false" class="locale-selector-link has-flex-shrink-none" href="#"
                                        data-bi-name="select-locale"><span
                                            class="icon docon docon-world is-size-4 has-margin-right-small"
                                            aria-hidden="true"></span><span class="local-selector-link-text"></span></a>
                                    <div class="has-margin-left-medium has-margin-right-medium has-flex-shrink-none">
                                        <div class="dropdown has-caret-up">
                                            <button
                                                class="dropdown-trigger button is-transparent is-small is-icon-only-touch has-inner-focus theme-dropdown-trigger"
                                                aria-controls="theme-menu-interactive" aria-expanded="false" title="테마"
                                                data-bi-name="theme">
                                                <span class="icon">
                                                    <span class="docon docon-sun" aria-hidden="true"></span>
                                                </span>
                                                <span>테마</span>
                                            </button>
                                            <div class="dropdown-menu" id="theme-menu-interactive" role="menu">
                                                <ul class="theme-selector has-padding-small">
                                                    <li class="theme is-block">
                                                        <button
                                                            class="button is-text is-small theme-control is-fullwidth has-flex-justify-content-start"
                                                            data-theme-to="light">
                                                            <span class="theme-light has-margin-right-small">
                                                                <span
                                                                    class="theme-selector-icon css-variable-support has-border is-inline-block has-body-background"
                                                                    aria-hidden="true">
                                                                    <svg class="svg" xmlns="http://www.w3.org/2000/svg"
                                                                        viewBox="0 0 22 14">
                                                                        <rect width="22" height="14"
                                                                            class="has-fill-body-background" />
                                                                        <rect x="5" y="5" width="12" height="4"
                                                                            class="has-fill-secondary" />
                                                                        <rect x="5" y="2" width="2" height="1"
                                                                            class="has-fill-secondary" />
                                                                        <rect x="8" y="2" width="2" height="1"
                                                                            class="has-fill-secondary" />
                                                                        <rect x="11" y="2" width="3" height="1"
                                                                            class="has-fill-secondary" />
                                                                        <rect x="1" y="1" width="2" height="2"
                                                                            class="has-fill-secondary" />
                                                                        <rect x="5" y="10" width="7" height="2" rx="0.3"
                                                                            class="has-fill-primary" />
                                                                        <rect x="19" y="1" width="2" height="2" rx="1"
                                                                            class="has-fill-secondary" />
                                                                    </svg>
                                                                </span>
                                                            </span>
                                                            <span role="menuitem">
                                                                밝음 </span>
                                                        </button>
                                                    </li>
                                                    <li class="theme is-block">
                                                        <button
                                                            class="button is-text is-small theme-control is-fullwidth has-flex-justify-content-start"
                                                            data-theme-to="dark">
                                                            <span class="theme-dark has-margin-right-small">
                                                                <span
                                                                    class="has-border theme-selector-icon css-variable-support is-inline-block has-body-background"
                                                                    aria-hidden="true">
                                                                    <svg class="svg" xmlns="http://www.w3.org/2000/svg"
                                                                        viewBox="0 0 22 14">
                                                                        <rect width="22" height="14"
                                                                            class="has-fill-body-background" />
                                                                        <rect x="5" y="5" width="12" height="4"
                                                                            class="has-fill-secondary" />
                                                                        <rect x="5" y="2" width="2" height="1"
                                                                            class="has-fill-secondary" />
                                                                        <rect x="8" y="2" width="2" height="1"
                                                                            class="has-fill-secondary" />
                                                                        <rect x="11" y="2" width="3" height="1"
                                                                            class="has-fill-secondary" />
                                                                        <rect x="1" y="1" width="2" height="2"
                                                                            class="has-fill-secondary" />
                                                                        <rect x="5" y="10" width="7" height="2" rx="0.3"
                                                                            class="has-fill-primary" />
                                                                        <rect x="19" y="1" width="2" height="2" rx="1"
                                                                            class="has-fill-secondary" />
                                                                    </svg>
                                                                </span>
                                                            </span>
                                                            <span role="menuitem">
                                                                어두움 </span>
                                                        </button>
                                                    </li>
                                                    <li class="theme is-block">
                                                        <button
                                                            class="button is-text is-small theme-control is-fullwidth has-flex-justify-content-start"
                                                            data-theme-to="high-contrast">
                                                            <span class="theme-high-contrast has-margin-right-small">
                                                                <span
                                                                    class="has-border theme-selector-icon css-variable-support is-inline-block has-body-background"
                                                                    aria-hidden="true">
                                                                    <svg class="svg" xmlns="http://www.w3.org/2000/svg"
                                                                        viewBox="0 0 22 14">
                                                                        <rect width="22" height="14"
                                                                            class="has-fill-body-background" />
                                                                        <rect x="5" y="5" width="12" height="4"
                                                                            class="has-fill-secondary" />
                                                                        <rect x="5" y="2" width="2" height="1"
                                                                            class="has-fill-secondary" />
                                                                        <rect x="8" y="2" width="2" height="1"
                                                                            class="has-fill-secondary" />
                                                                        <rect x="11" y="2" width="3" height="1"
                                                                            class="has-fill-secondary" />
                                                                        <rect x="1" y="1" width="2" height="2"
                                                                            class="has-fill-secondary" />
                                                                        <rect x="5" y="10" width="7" height="2" rx="0.3"
                                                                            class="has-fill-primary" />
                                                                        <rect x="19" y="1" width="2" height="2" rx="1"
                                                                            class="has-fill-secondary" />
                                                                    </svg>
                                                                </span>
                                                            </span>
                                                            <span role="menuitem">
                                                                고대비 </span>
                                                        </button>
                                                    </li>
                                                </ul>
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                <ul class="links" data-bi-name="footerlinks">
                                    <li><a data-mscc-ic="false"
                                            href="https://docs.microsoft.com/ko-kr/previous-versions/"
                                            data-bi-name="archivelink">이전 버전 문서</a></li>
                                    <li><a data-mscc-ic="false" href="https://docs.microsoft.com/ko-kr/teamblog"
                                            data-bi-name="bloglink">블로그</a></li>
                                    <li><a data-mscc-ic="false" href="https://docs.microsoft.com/ko-kr/contribute"
                                            data-bi-name="contributorGuide">참가</a></li>
                                    <li><a class="has-text-weight-semibold" data-mscc-ic="false"
                                            href="https://go.microsoft.com/fwlink/?LinkId=521839"
                                            data-bi-name="privacy">개인정보처리방침</a></li>
                                    <li><a data-mscc-ic="false" href="https://docs.microsoft.com/ko-kr/legal/termsofuse"
                                            data-bi-name="termsofuse">사용 조건</a></li>
                                    <li><a data-mscc-ic="false" href="https://aka.ms/sitefeedback"
                                            data-bi-name="feedback">사이트 피드백</a></li>
                                    <li><a data-mscc-ic="false"
                                            href="https://www.microsoft.com/en-us/legal/intellectualproperty/Trademarks/EN-US.aspx"
                                            data-bi-name="trademarks">상표</a></li>
                                    <li>&copy; Microsoft 2020</li>
                                </ul>
                            </footer>
                        </div>
                    </div>

                    <div class="is-size-7 right-container column is-one-quarter is-one-fifth-desktop is-hidden-mobile is-hidden-tablet-only"
                        data-bi-name="pageactions" role="complementary" aria-label="페이지 작업">
                        <div id="affixed-right-container" class="doc-outline is-fixed is-vertically-scrollable">


                            <div class="feedback-verbatim has-border-bottom has-padding-bottom-small has-margin-bottom-small"
                                data-bi-name="rating">
                                <div class="binary-rating">
                                    <div class="binary-rating-buttons">
                                        <h3
                                            class="has-text-weight-semibold has-margin-top-none has-margin-bottom-small">
                                            이 페이지가 도움이 되었나요?</h3>
                                        <div>
                                            <button
                                                class="thumb-rating like has-inner-focus has-padding-left-extra-small has-padding-right-extra-small"
                                                title="Yes" data-bi-name="rating-yes" aria-expanded="false"
                                                data-bi-sat="1" aria-controls="rating-container-desktop">
                                                <span aria-hidden="true" class="icon docon docon-like"></span>
                                                <span>Yes</span>
                                            </button>
                                            <button
                                                class="thumb-rating dislike has-inner-focus has-padding-none has-padding-right-extra-small"
                                                title="No" data-bi-name="rating-no" data-bi-sat="0"
                                                aria-expanded="false" aria-controls="rating-container-desktop">
                                                <span aria-hidden="true" class="icon docon docon-dislike"></span>
                                                <span>No</span>
                                            </button>
                                        </div>
                                    </div>
                                    <form class="feedback-verbatim-form is-hidden" id="rating-container-desktop">
                                        <div
                                            class="verbatim-textarea box is-relative has-box-shadow-none has-border has-margin-top-small has-padding-extra-small is-size-8">
                                            <label for="rating-textarea-desktop" class="visually-hidden">추가 피드백이
                                                있습니까?</label>
                                            <textarea id="rating-textarea-desktop" rows="4" maxlength="999"
                                                placeholder="추가 피드백이 있습니까?" required
                                                class="textarea has-border-none has-box-shadow-none has-inner-focus"></textarea>
                                        </div>
                                        <div
                                            class="buttons is-right has-margin-top-medium has-margin-right-extra-small">
                                            <button class="skip-rating button is-text is-link is-small"
                                                type="button">건너뛰기</button>
                                            <button class="submit-rating button is-primary is-small"
                                                data-bi-name="rating-verbatim" disabled type="submit">전송</button>
                                        </div>
                                    </form>
                                </div>
                                <div class="thankyou-rating is-hidden" tabindex="-1">
                                    <p>감사합니다.</p>
                                </div>
                            </div>
                            <nav data-bi-name="recommendation-sidebar" hidden id="recommended-content-nav"
                                role="navigation" aria-labelledby="recommended-content-nav-title">
                                <h3 id="recommended-content-nav-title">관련 문서</h3>
                            </nav>
                            <nav id="side-doc-outline" data-bi-name="intopic toc" role="navigation" aria-label="문서 개요">
                                <h3>이 문서의 내용</h3>
                            </nav>
                        </div>
                    </div>

                    <!--end of div.columns -->
                </div>

                <!--end of .primary-holder -->
            </section>

            <aside id="interactive-container"
                class="interactive-container is-visible-interactive column has-body-background-dark ">
            </aside>
        </div>

        <!--end of .mainContainer -->
    </div>

    <div id="openFeedbackContainer" class="openfeedback-container"></div>

    <div class="footerContainer has-default-focus is-hidden-interactive ">
        <footer id="footer" data-bi-name="footer" class="footer-layout uhf-container has-padding" role="contentinfo">

            <div class="is-flex is-full-height has-padding-right-extra-large-desktop">
                <a data-mscc-ic="false" class="locale-selector-link has-flex-shrink-none" href="#"
                    data-bi-name="select-locale"><span class="icon docon docon-world is-size-4 has-margin-right-small"
                        aria-hidden="true"></span><span class="local-selector-link-text"></span></a>
                <div class="has-margin-left-medium has-margin-right-medium has-flex-shrink-none">
                    <div class="dropdown has-caret-up">
                        <button
                            class="dropdown-trigger button is-transparent is-small is-icon-only-touch has-inner-focus theme-dropdown-trigger"
                            aria-controls="theme-menu" aria-expanded="false" title="테마" data-bi-name="theme">
                            <span class="icon">
                                <span class="docon docon-sun" aria-hidden="true"></span>
                            </span>
                            <span>테마</span>
                        </button>
                        <div class="dropdown-menu" id="theme-menu" role="menu">
                            <ul class="theme-selector has-padding-small">
                                <li class="theme is-block">
                                    <button
                                        class="button is-text is-small theme-control is-fullwidth has-flex-justify-content-start"
                                        data-theme-to="light">
                                        <span class="theme-light has-margin-right-small">
                                            <span
                                                class="theme-selector-icon css-variable-support has-border is-inline-block has-body-background"
                                                aria-hidden="true">
                                                <svg class="svg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 22 14">
                                                    <rect width="22" height="14" class="has-fill-body-background" />
                                                    <rect x="5" y="5" width="12" height="4"
                                                        class="has-fill-secondary" />
                                                    <rect x="5" y="2" width="2" height="1" class="has-fill-secondary" />
                                                    <rect x="8" y="2" width="2" height="1" class="has-fill-secondary" />
                                                    <rect x="11" y="2" width="3" height="1"
                                                        class="has-fill-secondary" />
                                                    <rect x="1" y="1" width="2" height="2" class="has-fill-secondary" />
                                                    <rect x="5" y="10" width="7" height="2" rx="0.3"
                                                        class="has-fill-primary" />
                                                    <rect x="19" y="1" width="2" height="2" rx="1"
                                                        class="has-fill-secondary" />
                                                </svg>
                                            </span>
                                        </span>
                                        <span role="menuitem">
                                            밝음 </span>
                                    </button>
                                </li>
                                <li class="theme is-block">
                                    <button
                                        class="button is-text is-small theme-control is-fullwidth has-flex-justify-content-start"
                                        data-theme-to="dark">
                                        <span class="theme-dark has-margin-right-small">
                                            <span
                                                class="has-border theme-selector-icon css-variable-support is-inline-block has-body-background"
                                                aria-hidden="true">
                                                <svg class="svg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 22 14">
                                                    <rect width="22" height="14" class="has-fill-body-background" />
                                                    <rect x="5" y="5" width="12" height="4"
                                                        class="has-fill-secondary" />
                                                    <rect x="5" y="2" width="2" height="1" class="has-fill-secondary" />
                                                    <rect x="8" y="2" width="2" height="1" class="has-fill-secondary" />
                                                    <rect x="11" y="2" width="3" height="1"
                                                        class="has-fill-secondary" />
                                                    <rect x="1" y="1" width="2" height="2" class="has-fill-secondary" />
                                                    <rect x="5" y="10" width="7" height="2" rx="0.3"
                                                        class="has-fill-primary" />
                                                    <rect x="19" y="1" width="2" height="2" rx="1"
                                                        class="has-fill-secondary" />
                                                </svg>
                                            </span>
                                        </span>
                                        <span role="menuitem">
                                            어두움 </span>
                                    </button>
                                </li>
                                <li class="theme is-block">
                                    <button
                                        class="button is-text is-small theme-control is-fullwidth has-flex-justify-content-start"
                                        data-theme-to="high-contrast">
                                        <span class="theme-high-contrast has-margin-right-small">
                                            <span
                                                class="has-border theme-selector-icon css-variable-support is-inline-block has-body-background"
                                                aria-hidden="true">
                                                <svg class="svg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 22 14">
                                                    <rect width="22" height="14" class="has-fill-body-background" />
                                                    <rect x="5" y="5" width="12" height="4"
                                                        class="has-fill-secondary" />
                                                    <rect x="5" y="2" width="2" height="1" class="has-fill-secondary" />
                                                    <rect x="8" y="2" width="2" height="1" class="has-fill-secondary" />
                                                    <rect x="11" y="2" width="3" height="1"
                                                        class="has-fill-secondary" />
                                                    <rect x="1" y="1" width="2" height="2" class="has-fill-secondary" />
                                                    <rect x="5" y="10" width="7" height="2" rx="0.3"
                                                        class="has-fill-primary" />
                                                    <rect x="19" y="1" width="2" height="2" rx="1"
                                                        class="has-fill-secondary" />
                                                </svg>
                                            </span>
                                        </span>
                                        <span role="menuitem">
                                            고대비 </span>
                                    </button>
                                </li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
            <ul class="links" data-bi-name="footerlinks">
                <li><a data-mscc-ic="false" href="https://docs.microsoft.com/ko-kr/previous-versions/"
                        data-bi-name="archivelink">이전 버전 문서</a></li>
                <li><a data-mscc-ic="false" href="https://docs.microsoft.com/ko-kr/teamblog"
                        data-bi-name="bloglink">블로그</a></li>
                <li><a data-mscc-ic="false" href="https://docs.microsoft.com/ko-kr/contribute"
                        data-bi-name="contributorGuide">참가</a></li>
                <li><a class="has-text-weight-semibold" data-mscc-ic="false"
                        href="https://go.microsoft.com/fwlink/?LinkId=521839" data-bi-name="privacy">개인정보처리방침</a></li>
                <li><a data-mscc-ic="false" href="https://docs.microsoft.com/ko-kr/legal/termsofuse"
                        data-bi-name="termsofuse">사용 조건</a></li>
                <li><a data-mscc-ic="false" href="https://aka.ms/sitefeedback" data-bi-name="feedback">사이트 피드백</a></li>
                <li><a data-mscc-ic="false"
                        href="https://www.microsoft.com/en-us/legal/intellectualproperty/Trademarks/EN-US.aspx"
                        data-bi-name="trademarks">상표</a></li>
                <li>&copy; Microsoft 2020</li>
            </ul>
        </footer>
    </div>

    <div id="action-panel" role="region" aria-label="작업 패널" class="action-panel has-default-focus" tabindex="-1"></div>
    <span id="adobe-target-experiment-container" hidden></span>
</body>

</html>